 
# zx_port_wait  zx_port_wait 

 
## NAME  名称 

<!-- Updated by update-docs-from-fidl, do not edit. -->  <！-由update-docs-from-fidl更新，请勿编辑。 ->

Wait for a packet arrival in a port.  等待数据包到达端口。

 
## SYNOPSIS  概要 

<!-- Updated by update-docs-from-fidl, do not edit. -->  <！-由update-docs-from-fidl更新，请勿编辑。 ->

```c
#include <zircon/syscalls.h>
#include <zircon/syscalls/port.h>

zx_status_t zx_port_wait(zx_handle_t handle,
                         zx_time_t deadline,
                         zx_port_packet_t* packet);
```
 

 
## DESCRIPTION  描述 

`zx_port_wait()` is a blocking syscall which causes the caller to wait until at least one packet is available. zx_port_wait（）是一个阻塞的系统调用，它使调用者等待，直到至少一个数据包可用为止。

Upon return, if successful *packet* will contain the earliest (in FIFO order) available packet data. 返回时，如果成功，* packet *将包含最早的（按FIFO顺序）可用的数据包数据。

The *deadline* indicates when to stop waiting for a packet (with respect to **ZX_CLOCK_MONOTONIC**) and will be automatically adjusted according to the job's[timer slack] policy. If no packet has arrived by the deadline,**ZX_ERR_TIMED_OUT** is returned.  The value **ZX_TIME_INFINITE** will result inwaiting forever.  A value in the past will result in an immediate timeout,unless a packet is already available for reading. *截止日期*指示何时停止等待数据包（相对于** ZX_CLOCK_MONOTONIC **），并将根据作业的[定时器松弛]策略自动进行调整。如果截止日期之前没有分组到达，则返回** ZX_ERR_TIMED_OUT **。值** ZX_TIME_INFINITE **将导致永远等待。过去的值将导致立即超时，除非已经有一个数据包可供读取。

Unlike [`zx_object_wait_one()`] and [`zx_object_wait_many()`] only one waiting thread is released (per available packet) which makes portsamenable to be serviced by thread pools. 与[`zx_object_wait_one（）`和[`zx_object_wait_many（）`]不同，仅释放了一个等待线程（每个可用数据包），这使得线程池可服务端口。

There are two classes of packets: packets queued by userspace with [`zx_port_queue()`] and packets queued by the kernel when objects a port is registered with change state. In bothcases the packet is always of type `zx_port_packet_t`: 数据包分为两类：用户空间使用[`zx_port_queue（）]排队的数据包，以及当对象端口更改状态注册时内核所排队的数据包。在这两种情况下，数据包始终为`zx_port_packet_t`类型：

```
struct zx_port_packet_t {
    uint64_t key;
    uint32_t type;
    zx_status_t status;
    union {
        zx_packet_user_t user;
        zx_packet_signal_t signal;
        zx_packet_exception_t exception;
        zx_packet_guest_bell_t guest_bell;
        zx_packet_guest_mem_t guest_mem;
        zx_packet_guest_io_t guest_io;
        zx_packet_guest_vcpu_t guest_vcpu;
        zx_packet_interrupt_t interrupt;
        zx_packet_page_request_t page_request;
    };
};
```
 

In the case of packets generated via [`zx_port_queue()`], *type* will be set to **ZX_PKT_TYPE_USER**, and the caller of [`zx_port_queue()`] controls all other values in the`zx_port_packet_t` structure. Access to the packet data is provided by the *user* member, withtype `zx_packet_user_t`: 在通过[`zx_port_queue（）`]生成数据包的情况下，* type *将设置为** ZX_PKT_TYPE_USER **，并且[`zx_port_queue（）`]的调用者控制zz_port_packet_t结构中的所有其他值。由* user *成员提供对分组数据的访问，类型为`zx_packet_user_t`：

```
typedef union zx_packet_user {
    uint64_t u64[4];
    uint32_t u32[8];
    uint16_t u16[16];
    uint8_t   c8[32];
} zx_packet_user_t;
```
 

For packets generated by the kernel, type can be one of the following values:  对于由内核生成的数据包，type可以是以下值之一：

**ZX_PKT_TYPE_SIGNAL_ONE** or **ZX_PKT_TYPE_SIGNAL_REP** - generated by objects registered via [`zx_object_wait_async()`]. ** ZX_PKT_TYPE_SIGNAL_ONE **或** ZX_PKT_TYPE_SIGNAL_REP **-由通过[`zx_object_wait_async（）`）注册的对象生成。

**ZX_PKT_TYPE_GUEST_BELL**, **ZX_PKT_TYPE_GUEST_MEM**, **ZX_PKT_TYPE_GUEST_IO**, or **ZX_PKT_TYPE_GUEST_VCPU** - generated by objects registered via [`zx_guest_set_trap()`]. ** ZX_PKT_TYPE_GUEST_BELL **，** ZX_PKT_TYPE_GUEST_MEM **，** ZX_PKT_TYPE_GUEST_IO **或** ZX_PKT_TYPE_GUEST_VCPU **-由通过[`zx_guest_set_trap（）`）注册的对象生成。

**ZX_PKT_TYPE_INTERRUPT** - generated by objects registered via [`zx_interrupt_bind()`].  ** ZX_PKT_TYPE_INTERRUPT **-由通过[`zx_interrupt_bind（）`]注册的对象生成。

**ZX_PKT_TYPE_PAGE_REQUEST** - generated by objects registered via [`zx_pager_create_vmo()`].  ** ZX_PKT_TYPE_PAGE_REQUEST **-由通过[`zx_pager_create_vmo（）`）注册的对象生成。

All kernel queued packets will have *status* set to **ZX_OK** and *key* set to the value provided to the registration syscall. For details on how to interpret the union, seethe corresponding registration syscall. 所有内核排队的数据包会将* status *设置为** ZX_OK **并将* key *设置为提供给注册syscall的值。有关如何解释联合的详细信息，请参见相应的注册系统调用。

 
## RIGHTS  权利 

<!-- Updated by update-docs-from-fidl, do not edit. -->  <！-由update-docs-from-fidl更新，请勿编辑。 ->

*handle* must be of type **ZX_OBJ_TYPE_PORT** and have **ZX_RIGHT_READ**.  *句柄*必须为** ZX_OBJ_TYPE_PORT **类型，并具有** ZX_RIGHT_READ **。

 
## RETURN VALUE  返回值 

`zx_port_wait()` returns **ZX_OK** on successful packet dequeuing.  zx_port_wait（）在成功出包后返回** ZX_OK **。

 
## ERRORS  错误 

**ZX_ERR_BAD_HANDLE** *handle* is not a valid handle.  ** ZX_ERR_BAD_HANDLE ** *句柄*不是有效的句柄。

**ZX_ERR_INVALID_ARGS** *packet* isn't a valid pointer  ** ZX_ERR_INVALID_ARGS ** *数据包*不是有效的指针

**ZX_ERR_ACCESS_DENIED** *handle* does not have **ZX_RIGHT_READ** and may not be waited upon. ** ZX_ERR_ACCESS_DENIED ** *句柄*没有** ZX_RIGHT_READ **，可能不会等待。

**ZX_ERR_TIMED_OUT** *deadline* passed and no packet was available.  ** ZX_ERR_TIMED_OUT ** *期限*已通过，没有数据包可用。

 
## SEE ALSO  也可以看看 

 
 - [timer slack](/docs/concepts/objects/timer_slack.md)  -[计时器松弛]（/ docs / concepts / objects / timer_slack.md）
 - [`zx_object_wait_async()`]  -[`zx_object_wait_async（）`]
 - [`zx_port_create()`]  -[`zx_port_create（）`]
 - [`zx_port_queue()`]  -[`zx_port_queue（）`]

<!-- References updated by update-docs-from-fidl, do not edit. -->  <！-由update-docs-from-fidl更新的引用，请勿编辑。 ->

