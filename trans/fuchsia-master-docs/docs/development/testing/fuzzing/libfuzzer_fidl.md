 
# Fuzzing FIDL Servers with LibFuzzer on Fuchsia  在紫红色的LibFuzzer上模糊FIDL服务器 

 
## Quick-start guide  快速入门指南 

An example fuzzer is defined in `//garnet/examples/fidl/echo_server_cpp/fuzzer`. If you are not familiar with fuzzers, see [LibFuzzer on Fuchsia](libfuzzer.md). Fuzzing FIDL servers with `LibFuzzer` on fuchsia requires gn targets that will generate a fuzz target and writing some code to provide an instance of the server to be fuzzed.  一个模糊器示例在`// garnet / examples / fidl / echo_server_cpp / fuzzer`中定义。如果您不熟悉fuzzer，请参阅[Fuchsia上的LibFuzzer]（libfuzzer.md）。用紫红色的LibFuzzer来模糊FIDL服务器需要gn目标，它将生成一个模糊目标并编写一些代码以提供要模糊的服务器实例。

 
1. Add `fuzzers = {protocol = "fully.qualified.fidl.ProtocolName"}` to your `fidl()` gn target.  1.将`fuzzers = {protocol =“ fully.qualified.fidl.ProtocolName”}}添加到您的`fidl（）`gn目标中。
1. Depending on the language you are using:  1.根据您使用的语言：
    * At the C++ level (easy mode): Use the `FIDL_FUZZER_DEFINITION()` macro in `//sdk/lib/fidl/cpp/fuzzing/server_provider.h` to define a server provider for your interface and server implementation class. This will automatically define the C symbols described below. See `//garnet/examples/fidl/echo_server_cpp/fuzzer` for a reference example. *在C ++级别（简单模式）：使用`// sdk / lib / fidl / cpp / fuzzing / server_provider.h`中的`FIDL_FUZZER_DEFINITION（）`宏来为您的接口和服务器实现类定义服务器提供程序。这将自动定义以下所述的C符号。有关参考示例，请参见`// garnet / examples / fidl / echo_server_cpp / fuzzer`。
    * At the C level (hard mode): Implement a library that defines the following symbols: *在C级别（硬模式）：实现定义以下符号的库：
      * `zx_status_t fuzzer_init()`: Instantiate server implementation.  *`zx_status_t fuzzer_init（）`：实例化服务器实现。
      * `zx_status_t fuzzer_connect(zx_handle_t, async_dispatcher_t*)`: Bind server implementation to the channel handle. Optionally, use the dispatcher if your server can be fuzzed on the same thread as fuzzer clients (see [note on threading][single-thread-dispatcher-preferred]).  *`zx_status_t fuzzer_connect（zx_handle_t，async_dispatcher_t *）`：将服务器实现绑定到通道句柄。 （可选）如果服务器可以与模糊器客户端使用同一线程进行模糊处理，请使用调度程序（请参阅[关于线程的说明] [单线程分配器优先]）。
      * `zx_status_t fuzzer_disconnect(zx_handle_t, async_dispatcher_t*)`: Unbind server implemementation from the channel handle.  *`zx_status_t fuzzer_disconnect（zx_handle_t，async_dispatcher_t *）`：从通道句柄中取消服务器实现。
      * `zx_status_t fuzzer_clean_up()`: Clean up server implementation. If any of these returns a status other than `ZX_OK`, then the fuzzer will cleanup and halt. *`zx_status_t fuzzer_clean_up（）`：清理服务器实现。如果其中任何一个返回的状态不是ZX_OK，则模糊器将清理并停止。
1. Define a `fidl_protocol_fuzzer()` gn target. Specify:  1.定义一个`fidl_protocol_fuzzer（）`gn目标。指定：
    * `fidl = //path/to:fidl_gn_target` (the `fidl()` target mentioned above).  *`fidl = // path / to：fidl_gn_target`（上面提到的`fidl（）`目标）。
    * `protocol = "fully.qualified.fidl.ProtocolName"`.  *`protocol =“ fully.qualified.fidl.ProtocolName”`。
    * `deps = [... :your_library ...]` (the one mentioned above, defining `fuzzer_...` symbols).  *`deps = [...：your_library ...]`（上面提到的那个，定义了'fuzzer _...`符号）。
    * Anything else needed for a `fuzzer()` gn target that fuzzes your server (see [LibFuzzer on Fuchsia](libfuzzer.md) for details).  *使服务器模糊不清的`fuzzer（）`gn目标所需的其他任何信息（有关详细信息，请参见[Fuchsia上的LibFuzzer]（libfuzzer.md））。
1. Add `fidl_protocol_fuzzer()` target to `fuzzers = [ ... ]` in a new or existing `fuzzers_package()` gn target (see [LibFuzzer on Fuchsia](libfuzzer.md) for details).  1.在新的或现有的fuzzers_package（）gn目标中，将`fidl_protocol_fuzzer（）`目标添加到`fuzzers = [...]`中（有关详细信息，请参见[Fuchsia上的LibFuzzer]（libfuzzer.md））。

[TOC]  [目录]

 
## Implementation details  实施细节 

The bulk of a FIDL server implementation fuzz target is C++ code generated by `fidlgen` that expects a handful of C symbols to provide an API to the FIDL server implementation. The generated code contains a global `async::Loop`, bound to its initial thread, that is reused for the client side of a FIDL connection on each run of the fuzz target. `LibFuzzer` repeatedly invokes the same fuzz target with different inputs. The generated fuzz target code will:  FIDL服务器实现模糊目标的大部分是由`fidlgen`生成的C ++代码，该代码期望少数C符号为FIDL服务器实现提供API。生成的代码包含一个绑定到其初始线程的全局`async :: Loop`，在每个模糊目标运行时，FIDL连接的客户端都可以重新使用该全局async :: Loop。 “ LibFuzzer”会重复调用具有不同输入的相同模糊目标。生成的模糊目标代码将：

 
* Invoke `fuzzer_init()`, initializing the server to be fuzzed.  *调用`fuzzer_init（）`，初始化要被模糊化的服务器。
* Instantiates a pair of `zx::channel`s.  *实例化一对`zx :: channel`s。
* Initializes an `fidl::InterfacePtr` of the appropriate type, bound to a channel end and the loop's dispatcher.  *初始化一个适当类型的`fidl :: InterfacePtr`，绑定到通道端和循环的调度程序。
* Invoke `fuzzer_connect(raw_server_channel_handle, loop->dispatcher())`, establishing a connection with the server and allowing the server to opt in to using the same dispatcher as the client if its API is compatible with such a scheme (see [note on threading][single-thread-dispatcher-preferred]).  *调用`fuzzer_connect（raw_server_channel_handle，loop-> dispatcher（））`，与服务器建立连接，并允许服务器选择使用与客户端相同的调度程序（如果其API与这种方案兼容的话）（请参阅[注意线程] [首选单线程调度]）。
* Invoke a method through its `fidl::InterfacePtr`.  *通过其`fidl :: InterfacePtr`调用方法。
* Set its `async::Loop` to run-until-idle.  *将其async :: Loop设置为run-until-idle。
* Synchronize with the method's callback via a `zx::event`.  *通过`zx :: event`与方法的回调同步。
* Invoke `fuzzer_disconnect(raw_server_channel_handle, loop->dispatcher())`, allowing the server to clean up its end of the connection.  *调用`fuzzer_disconnect（raw_server_channel_handle，loop-> dispatcher（））`，允许服务器清理其连接结束。
* Invoke `fuzzer_clean_up()` to tear down the server instance.  *调用`fuzzer_clean_up（）`拆除服务器实例。

 
### Allocation of fuzz target input to FIDL messages  将模糊目标输入分配给FIDL消息 

In broad strokes, the first two bytes are used to select a protocol and method pair from among those defined in the FIDL source file. In the case of a FIDL file that contains many protocols, but only one is enabled in the fuzzer, discovery of meaningful inputs relies on `LibFuzzer`'s coverage-guided engine to deduce that the first bytes of a certain form cause the fuzzer to exercise almost no code.  宽泛地讲，前两个字节用于从FIDL源文件中定义的协议和方法对中选择一个协议和方法对。如果FIDL文件包含许多协议，但在模糊器中仅启用了一个协议，则有意义的输入的发现依赖于LibFuzzer的覆盖率导向引擎来推断某种形式的前几个字节会导致模糊器几乎没有代码。

After a protocol and method pair are identified, the remaining bytes are carved up as follows:  识别协议和方法对后，其余字节将按以下方式划分：

 
* Each type has a trait that defines the minimum number of bytes it requires.  *每种类型都有一个特征，该特征定义了所需的最小字节数。
* If insufficient bytes are input, the fuzz target exits immediately.  *如果输入的字节数不足，模糊目标将立即退出。
* Otherwise the "slack" bytes that exceed the minimum required for the method parameters are divided evenly among parameters and an allocation trait for each type is invoked to construct an object of the appropriate type using at most `MinForParam + SlackForParam` bytes.  *否则，超出方法参数要求的最小值的“松弛”字节将在参数之间平均分配，并且每种类型的分配特征均被调用，以最多使用MinForParam + SlackForParam`字节来构造适当类型的对象。

In terms of allocation trait details, collection and numeric types have relatively natural interpretations based on the collection of bytes to be transformed into an object. Handles are treated like numeric types, which can be expected to lead to errors when the server attempts to exercise them.  在分配特征细节方面，集合和数字类型基于要转换为对象的字节集合而具有相对自然的解释。将句柄视为数字类型，当服务器尝试使用它们时，可能会导致错误。

 
### A note about threading  关于线程的注释{#a-note-about-threading}  {关于线程的注释}

It is **highly** desirable to keep the fuzz target single-threaded. That is, use `ServerProviderDispatcherMode::kFromCaller` in C++ or use the `async_dispatcher_t*` passed to `fuzzer_connect` in C. This is preferred because it increases the liklihood that bugs found by the fuzzer will be consistently reproducible.  高度希望保持模糊目标为单线程。也就是说，在C ++中使用ServerProviderDispatcherMode :: kFromCaller或在C中使用传递给fuzzer_connect的async_dispatcher_t *。这是首选方法，因为这增加了由模糊器发现的错误将始终可再现的可能性。

 
## Future work  未来的工作 

The following work is planned for improving fuzzing FIDL server implementations with `LibFuzzer` on Fuchsia:  计划进行以下工作，以通过在紫红色的LibFuzzer中改进模糊FIDL服务器的实现：

 
1. Language bindings/libraries for C/C++, rust, and go.  1. C / C ++，Rust和Go的语言绑定/库。
1. Improved distribution of fuzz input data over method input signature. For example, some fuzz inputs should lead to using legitimate handles rather than treating handles as numeric types.  1.改进了模糊输入数据在方法输入签名上的分配。例如，一些模糊输入应该导致使用合法句柄，而不是将句柄视为数字类型。
1. Fuzzing multiple method invocations in the same test run.  1.在同一测试运行中模糊多个方法调用。
1. Fuzzing multiple connections in the same test run.  1.在同一测试运行中模糊多个连接。

