 
# Developing with Fuchsia packages  使用紫红色包装进行开发 

Almost everything that exists on a Fuchsia system is a [Fuchsia package][pkg-struct]. Even the contents of /system are backed by a Fuchsia package. Whether it isimmediately apparent or not almost everything you see on Fuchsia lives in apackage. This document will cover the basics of a package-driven workflow whereyou [build][pkg-doc] a package and push it to a Fuchsia device which is reachablevia IP from your development host. 紫红色系统上几乎所有的东西都是[紫红色包] [pkg-struct]。甚至/ system的内容都由Fuchsia软件包提供支持。无论是立即可见还是您在紫红色上看到的几乎所有东西都包装在一起。本文档将介绍软件包驱动的工作流程的基础知识，您可以在其中[构建] [pkg-doc]软件包并将其推送到可通过开发主机的IP到达的Fuchsia设备。

 
## Pre-requisites and overview  前提条件和概述 

The host and target must be able to communicate over IP. In particular it must be possible to SSH from the development host to the target device, andthe target device must be able to connect via TCP to the development host onport 8083. The SSH connection is used to issue commands to the target device. 主机和目标必须能够通过IP进行通信。特别是必须能够从开发主机到目标设备进行SSH，并且目标设备必须能够通过TCP连接到端口8083上的开发主机。SSH连接用于向目标设备发出命令。

The development host will run a simple, static file, HTTP server which makes the updates available to the target. This HTTP server is part of the Fuchsia sourcecode and built automatically. 开发主机将运行一个简单的静态文件HTTP服务器，该服务器使更新可用于目标。该HTTP服务器是Fuchsia源代码的一部分，是自动构建的。

The target is instructed to look for changes on the development host via a couple of commands that are run manually. When the update system on the targetsees these changes it will fetch the new software from the HTTP server runningon the host. The new software will be available until the target is rebooted. 指示目标通过一些手动运行的命令在开发主机上查找更改。当目标服务器上的更新系统发生这些更改时，它将从主机上运行的HTTP服务器获取新软件。新软件将一直可用，直到重新引导目标为止。

 
## Building  建造 

> TODO(jmatt): improve to talk about wider variety of build options  > TODO（jmatt）：改进以讨论更多的构建选项

To build a package containing the required code, a package type build rule is used. If one of these needs to be created for the target package, consult thereference [page][pkg-doc] for this. Some build rule types are actuallyextensions of the package rule type, for example [`flutter_app`][flutter-gni]extends the package type. The rule must also not set `deprecated_system_image` to true,things in the system image can only be updated by [paving][paver]. 要构建包含所需代码的软件包，请使用软件包类型构建规则。如果需要为目标软件包创建其中之一，请参考[page] [pkg-doc]。一些构建规则类型实际上是包规则类型的扩展，例如[`flutter_app`] [flutter-gni]扩展了包类型。该规则也不能将“ deprecated_system_image”设置为true，系统映像中的内容只能通过[paving] [paver]进行更新。

Once an appropriate build rule is available the target package can be re-generated by running `fx build` or `fx build <target_name>`. 一旦有合适的构建规则可用，就可以通过运行`fx build`或`fx build <target_name>`来重新生成目标软件包。

 
## Connecting host and target  连接主机和目标 

The Fuchsia source contains a simple HTTP server which serves static files. The build generates a [TUF][TUF-home] file tree which is served. 紫红色的源包含一个简单的HTTP服务器，该服务器提供静态文件。该构建生成一个[TUF] [TUF-home]文件树，该文件树将被提供。

The update agent on the target does not initially know where to look for updates. To connect the agent on the target to the HTTP server running on thedevelopment host, it must be told the IP address of the development host.The host HTTP server is started and the update agent is configured by calling`fx serve -v` or `fx serve-updates -v`.  `fx serve` will run both the bootserverand the update server and is often what people use. `fx serve-updates` runs justthe update server. In both cases, `-v` is recommended because the command willprint more output which may assist with debugging. If the host connectssuccessfully to the target you will see the message `Ready to push packages!` inthe shell on your host. 目标上的更新代理最初不知道在哪里查找更新。要将目标上的代理连接到在开发主机上运行的HTTP服务器，必须告知开发主机的IP地址。启动主机HTTP服务器，并通过调用fx serve -v或``配置更新代理。 fx serve-updates -v`。 “ fx serve”将同时运行引导服务器和更新服务器，并且经常被人们使用。 `fx serve-updates`只运行更新服务器。在这两种情况下，建议使用-v，因为该命令将打印更多输出，这可能有助于调试。如果主机成功连接到目标，您将在主机的外壳中看到消息“准备推送软件包！”。

The update agent on the target will remain configured until it is repaved or persistent data is lost. The host will attempt to reconfigure the update agentwhen the target is rebooted. 目标上的更新代理将保持配置状态，直到重新安装它或永久性数据丢失为止。重启目标后，主机将尝试重新配置更新代理。

 
## Triggering package updates  触发软件包更新 

In the future certain updates may happen automatically, but today the update agent on the target must be told to look for an update. To accomplish this a SSHconnection is made from the host to the target and a command is run to tell theupdate agent to look for a new package. To trigger the update invoke`fx build-push <package_name>`. The &lt;package_name&gt; argument can berepeated to push multiple packages. The &lt;package_name&gt; argument can alsobe omitted to cause *all* packages, except the system package, to be pushed.The number of packages is typically large and the `build-push` mechanism doesn'tscale well. To update all the packages on a target it will be faster to do an[OTA]. 将来某些更新可能会自动发生，但是今天必须通知目标上的更新代理寻找更新。为此，要从主机到目标建立SSH连接，然后运行命令告诉更新代理寻找新软件包。要触发更新，请调用fx build-push <package_name>。 lt; package_namegt;可以重复此参数以推送多个程序包。 lt; package_namegt;也可以省略该参数以导致除系统软件包以外的所有软件包被推送。软件包的数量通常很大，并且build-push机制不能很好地扩展。要更新目标上的所有软件包，执行[OTA]会更快。

The update package(s) will be available until the target is rebooted. Following a reboot the package data will still be on local storage, but will beinaccessible. This is a limitation of the current implementation which willimprove over time. When doing an [OTA] the result of the OTA is persistentacross reboots. 在重启目标之前，更新软件包将一直可用。重新启动后，程序包数据仍将保留在本地存储中，但将无法访问。这是当前实施方式的局限性，随着时间的推移，这种局限性将得到改善。执行[OTA]时，OTA的结果在重新启动后会持续存在。

 
## Triggering an OTA  触发OTA 

Sometimes there may be many packages changed or the kernel may change or there may be changes in the system package. To get kernel changes or changes in thesystem package an OTA or [pave][paver] is *required*, `fx build-push` isn'tcapable of updating these things. An OTA update will usually be faster thanpaving. When updating a large number of packages an OTA update will be fasterthan `fx build-push` because of its more optimized implementation. 有时可能有许多软件包已更改，或者内核可能已更改，或者系统软件包中可能有更改。要获得内核更改或系统软件包中的更改，需要*要求使用OTA或[pave] [paver]，`fx build-push`无法更新这些内容。 OTA更新通常比铺砌更快。当更新大量软件包时，OTA更新将比`fx build-push`更快，因为它的实现更加优化。

The command `fx ota` asks the target device to perform an update from any of the update sources available to it. To OTA update a build made on the dev host toa  target on the same LAN, first build the system you want. If `fx serve [-v]`isn't already running, start it so the target can use the development host as anupdate source. The `-v` option will show more information about the files thetarget is requesting from the host. If the `-v` flag was used there shouldbe a flurry of output as the target retrieves all the new files. Followingcompletion of the OTA the device will reboot. 命令“ fx ota”要求目标设备从其可用的任何更新源中执行更新。要OTA将在开发主机上进行的构建更新为同一LAN上的目标，请首先构建所需的系统。如果`fx serve [-v]`尚未运行，请启动它，以便目标可以将开发主机用作更新源。 -v选项将显示有关目标服务器从主机请求的文件的更多信息。如果使用了`-v`标志，那么在目标检索所有新文件时应该会有大量输出。 OTA完成后，设备将重新启动。

 

 
## Just the commands  只是命令 

 
  * `fx serve -v` (to run the update server for both build-push and ota)  *`fx serve -v`（同时为build-push和ota运行更新服务器）
    * `fx serve-updates -v` (to run only the update server, not the bootserver)  *`fx serve-updates -v`（仅运行更新服务器，而不运行引导服务器）
  * `fx build-push <package_name>` (each time a change is made you want to push)  *`fx build-push <package_name>`（每次更改都要推送）
  * `fx shell "killall sysmgr"` (optional, depending on your component)  *`fx shell“ killall sysmgr”`（可选，取决于您的组件）
  * `fx ota` (to trigger a full system update and reboot)  *`fx ota`（触发完整的系统更新并重启）

 
## Issues and considerations  问题与注意事项 

 
### You can fill up your disk  你可以填满你的磁盘 

Every update pushed is stored in the content-addressed file system, blobfs. Following a reboot the updated packages may not be available because the indexthat locates them in blobfs is only held in RAM. The system currently does notgarbage collect inaccessible or no-longer-used packages (having garbage tocollect is a recent innovation!), but will eventually. Until then, the easiestsolution is to re-pave the device, which will clear out blobfs. 推送的每个更新都存储在内容寻址文件系统blobfs中。重新启动后，更新的软件包可能不可用，因为在blobfs中找到它们的索引仅保存在RAM中。该系统目前不会垃圾收集无法访问或不再使用的软件包（收集垃圾是最近的一项创新！），但最终会。在此之前，最简单的解决方案是重新铺设设备，这将清除斑点。

 
### Restarting without rebooting  重新启动而不重新启动 

If the package being updated hosts a service managed by Fuchsia that service may need to be restarted. Rebooting is undesirable both because it is slow andbecause the package will revert to the version paved on the device. In thiscase 'fuchsia' can be restarted. More accurately, `sysmgr` can be restarted.`sysmgr` can be restarted by running `fx shell "killall sysmgr"`. 如果要更新的程序包托管由Fuchsia管理的服务，则可能需要重新启动该服务。重新启动是不可取的，因为它很慢，而且因为程序包将还原为铺在设备上的版本。在这种情况下，“紫红色”可以重新启动。更准确地说，可以重新启动sysmgr。通过运行fx shell“ killall sysmgr”可以重新启动sysmgr。

 
### Updating things in the system package  更新系统软件包中的内容 

If a package is part of the system image (because its package rule sets `deprecated_system_image = "true"`) then it can not be updated with the package update flow.To update the system package, an [OTA] is required which requires areboot at present. 如果软件包是系统映像的一部分（因为其软件包规则集`deprecated_system_image =“ true”`），则无法使用软件包更新流程进行更新。要更新系统软件包，需要使用[OTA]，该软件包需要areboot现在。

The system package is intended for a few key pieces of code and data that are involved in booting the system. There are very few reasons that code should needto live in the system package. Being a driver, for example, is not a reasonsomething should live in the system package. If there is an architectural reasonfor something to be in the system package it is likely that either thearchitecture is expected to change or a redesign should be considered to removethe system package constraint. 该系统软件包用于引导系统所涉及的一些关键代码和数据。将代码保留在系统包中的理由很少。例如，作为驱动程序并不是系统软件包中应该存在的原因。如果有体系结构原因要在系统软件包中添加某些内容，则可能是预期体系结构发生更改，或者应该考虑重新设计以消除系统软件包约束。

 
### Packaging code outside the Fuchsia tree  紫红色树外的包装代码 

Packaging and pushing code that lives outside the Fuchsia tree is possible, but will require more work. The Fuchsia package format is quite simple. It consistsof a metadata file describing the package contents which is described in moredetail in the [Fuchsia package][pkg-struct] documentation. The metadata file isadded to a TUF file tree and each of the contents are named after their Merkleroot hash and put in a directory at the root of the TUF file tree called 'blobs'. 可以打包和推送位于紫红色的树之外的代码，但需要做更多的工作。紫红色的包装格式非常简单。它由描述包内容的元数据文件组成，该文件在[Fuchsia包] [pkg-struct]文档中有更详细的描述。元数据文件被添加到TUF文件树中，并且每个内容均以其Merkleroot哈希命名，并放在TUF文件树根目录中的目录中，称为“ blobs”。

