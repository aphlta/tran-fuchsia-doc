 
# Testing Rust code  测试Rust代码 

This document describes best practices for writing tests for Rust code, and paired with ["Running tests as components"][component_tests] describes how tocomponent-ize, package, and run these tests. 本文档描述了编写Rust代码测试的最佳做法，并与[“将测试作为组件运行”] [component_tests]配对，描述了如何对这些测试进行组件化，打包和运行。

This document is targeted towards developers working inside of `fuchsia.git`, and the workflow described is unlikely to work for SDK consumers. 本文档针对的是在`fuchsia.git`内部工作的开发人员，所描述的工作流程不太可能对SDK使用者有效。

The source code for this tutorial is available at [`//examples/hello_world/rust`][example-src]. 本教程的源代码位于[`// examples / hello_world / rust`] [example-src]。

 
## Unit tests  单元测试 

 
### Adding tests to code  向代码添加测试 

The idiomatic way for adding Rust unit tests works just as well inside of Fuchsia as it does outside, and can be easily accomplished by dropping thefollowing snippet into the bottom of whatever test you want to write: 添加Rust单元测试的惯用方式在紫红色的内部和外部都一样，并且可以通过将以下代码段放到要编写的任何测试的底部来轻松实现：

```rust
{% includecode gerrit_repo="fuchsia/fuchsia" gerrit_path="examples/hello_world/rust/src/main.rs" region_tag="test_mod" adjust_indentation="auto" %}
```
 

This will cause a new mod named `tests` to be created, and this mod will only be included when building unit tests. Any functions annotated with `#[test]` willbe run as a test, and if the function successfully returns then the test passes. 这将导致创建一个名为“ tests”的新mod，并且仅在构建单元测试时才会包含此mod。任何带有“ [test]”注解的函数都将作为测试运行，如果该函数成功返回，则测试通过。

For tests exercising asynchronous code, use the `#[fasync::run_until_stalled(test)]` annotation as an alternative tousing an asynchronous executor. 对于使用异步代码的测试，请使用[fasync :: run_until_stalled（test）]批注代替使用异步执行程序。

```rust
{% includecode gerrit_repo="fuchsia/fuchsia" gerrit_path="examples/hello_world/rust/src/main.rs" region_tag="async_test" adjust_indentation="auto" %}
```
 

 
### Building tests  建筑测试 

The unit tests can be automatically built by Rust targets (i.e. either `rustc_binary` or `rustc_library`).  The approaches are by and large similar. 单元测试可以由Rust目标（即“ rustc_binary”或“ rustc_library”）自动构建。这些方法大致相似。

 
#### Building tests for a Rust binary  构建Rust二进制文件的测试 

This section is useful if you are testing a rust *binary* (i.e. you have a `main.rs`). If you have a library instead, see the next section. 如果您正在测试锈迹*二进制*（即您有一个“ main.rs”），则本节非常有用。如果您有图书馆，请参阅下一节。

Your `BUILD.gn` file first needs to make available the `rustc_binary` template by importing it: 您的`BUILD.gn`文件首先需要通过导入来使`rustc_binary`模板可用：

```gn
import("//build/rust/rustc_binary.gni")
```
 

Unit tests are built by the `rustc_binary` GN template only if the setting `with_unit_tests = true` is added: 仅在添加`with_unit_tests = true`设置时，`rustc_binary` GN模板才能构建单元测试：

```gn
{% includecode gerrit_repo="fuchsia/fuchsia" gerrit_path="examples/hello_world/rust/BUILD.gn" region_tag="rustc_tests" adjust_indentation="auto" %}
```
 

Setting `with_unit_tests = true` causes this build rule to generate two different executables, one with the provided and one with `_bin_test` appendedto the provided name. 设置`with_unit_tests = true`会使该构建规则生成两个不同的可执行文件，一个带有提供的可执行文件，另一个带有附加在提供的名称后的_bin_test`。

In our example here, the executable names that are created are called:  在此处的示例中，创建的可执行文件名称称为：

 
* `hello_world_rust`; and  *`hello_world_rust`;和
* `hello_world_rust_bin_test`.  *`hello_world_rust_bin_test`。

 
#### Building tests for a Rust library  构建Rust库的测试 

Your `BUILD.gn` file first needs to make available the `rustc_library` template by importing it: 您的`BUILD.gn`文件首先需要通过导入来使`rustc_library`模板可用：

```gn
import("//build/rust/rustc_library.gni")
```
 

Unit tests are built by the `rustc_library` GN template only if the setting `with_unit_tests = true` is added, similarly to how it is done in the caseof `rustc_binary` above. 仅在添加`with_unit_tests = true`设置的情况下，才由`rustc_library` GN模板构建单元测试，这与上面的`rustc_binary`情况类似。

In this case, however, a **differently named** test binary is created:  但是，在这种情况下，将创建一个“不同名称”的测试二进制文件：

 
* `hello_world_rust_lib_test`.  Note that the name of the binary is different from the name generated by the library. *`hello_world_rust_lib_test`。请注意，二进制文件的名称与库生成的名称不同。

The binary names are important because they will be used in followup steps.  二进制名称很重要，因为它们将在后续步骤中使用。

 
### Packaging and running tests  包装和运行测试 

To run the tests that were generated by previous targets, they will need to be packaged first.  This is currently a two step process, which includes writinga package manifest and the package build target. 要运行由先前目标生成的测试，必须先将它们打包。当前这是一个两步过程，其中包括编写程序包清单和程序包构建目标。

 
#### Writing the package manifest  编写包清单 

A package manifest is currently required.  The manifest is placed in the `meta/` subdirectory, immediately below the directory containing your `BUILD.gn`file. 当前需要软件包清单。清单位于“ meta /”子目录中，位于包含“ BUILD.gn”文件的目录下。

A minimal manifest file is shown below, and **must** be named the same as the `name` attribute of the target that is being generated by the `rustc_binary` or`rustc_library` above. 最小清单文件如下所示，并且必须与上面的“ rustc_binary”或“ rustc_library”所生成的目标的“ name”属性相同。

In case of a manifest for a `rustc_binary` given above, the resulting manifest is: 对于上面给出的`rustc_binary`的清单，结果清单为：

```cmx
{
        "program": {
               "binary": "test/hello_world_rust_bin_test"
        }
}
```
 

Note:  注意：

 
* The binary name is based on the `name = "hello_world_rust"` line on the `rustc_binary` target. *二进制名称基于“ rustc_binary”目标上的“ name =“ hello_world_rust””行。
* The binary is inside a `test/` subdirectory.  This placement is implicit in the `rustc_binary` build rule. *二进制文件位于`test /`子目录中。这个位置在“ rustc_binary”构建规则中是隐含的。
* You may have noticed that the package manifests are somewhat formulaic. In the future, we may find ourselves able to automatically generate thepackage manifests instead of having to write them out by hand. *您可能已经注意到，包装清单明显是公式化的。将来，我们可能会发现自己能够自动生成软件包清单，而不必手动将其写出。

In case of a manifest for a `rustc_library`, the manifest and the naming scheme are similar.  But pay attention to the subtle naming difference in the valuefor the stanza `program.binary`: 如果是“ rustc_library”的清单，清单和命名方案是相似的。但是请注意节`program.binary`的值之间的细微命名差异：

```cmx
{
        "program": {
               "binary": "test/hello_world_rust_lib_test"
        }
}
```
 

The `_lib_test` suffix is hard-coded in the `rustc_library` build rule, and `hello_world_rust` again comes from the `name` attribute in the build rule. _lib_test的后缀被硬编码在rustc_library的构建规则中，而helloworld_rust再次来自于构建规则的name属性。

 
#### Writing the package build target  编写软件包构建目标 

For the Hello world binary example, the test package needs to reference the generated targets, `bin_test` (based on target name `bin` and the implicitsuffix `_test`), and `hello_world_rust_bin_test` (based on the value of `name`stanza). 对于Hello world二进制示例，测试包需要引用生成的目标bin_test（基于目标名称bin和隐式后缀_test）和helloworld_rust_bin_test（基于name节的值） ）。

If you are building a library instead, then the library name will be `hello_world_rust_lib_test`. 如果您正在构建库，则库名称将为`hello_world_rust_lib_test`。

```gn
{% includecode gerrit_repo="fuchsia/fuchsia" gerrit_path="examples/hello_world/rust/BUILD.gn" indented_block="^test_package\(\"hello_world_rust_tests\"\) {" %}
```
 

To run the tests run:  要运行测试，请运行：

```sh
fx run-test hello_world_rust_tests
```
 

Note: that in order to use `fx run-test`, you can't override `package_name="..."` in your `package`  or `test_package` declaration. Thisissue is tracked by BLD-338. 注意：为了使用`fx run-test`，您不能在`package`或`test_package`声明中覆盖`package_name =“ ...”`。 BLD-338对此问题进行了跟踪。

 

For information on packaging and running tests, please refer to the [documentation on running tests as components][component_tests]. 有关打包和运行测试的信息，请参考[作为组件运行测试的文档] [component_tests]。

 

