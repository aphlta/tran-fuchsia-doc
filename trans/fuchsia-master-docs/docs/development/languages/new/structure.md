 
# How to structure Fuchsia support for a language  如何构建樱红色对语言的支持 

This document describes the structure languages typically when supporting Fuchsia. 本文档介绍了支持Fuchsia时通常使用的结构语言。

 
## System calls  系统调用 

The lowest level of Fuchsia support in a language provides access to the [Zircon system calls](/docs/reference/syscalls/).Exposing these system calls lets programs written in the language interact withthe kernel and, transitively, with the rest of the system. 最低的Fuchsia支持以某种语言提供对[Zircon系统调用]（/ docs / reference / syscalls /）的访问。公开这些系统调用可使使用该语言编写的程序与内核以及与之交互的其余部分交互。系统。

Programs cannot issue system calls directly. Instead, they make system calls by calling functions in the [vDSO](/docs/concepts/kernel/vdso.md),which is loaded into newly created processes by their creator. 程序无法直接发出系统调用。相反，它们通过调用[vDSO]（/ docs / concepts / kernel / vdso.md）中的函数进行系统调用，该函数由其创建者加载到新创建的进程中。

The public entry points for the vDSO are defined in [//zircon/syscalls](/zircon/syscalls/).This file is processed by the [kazoo](/docs/concepts/kernel/vdso.md#kazoo-tool)tool. vDSO的公共入口点在[// zircon / syscalls]（/ zircon / syscalls /）中定义。此文件由[kazoo]（/ docs / concepts / kernel / vdso.mdkazoo-tool）工具处理。

 
## Async  异步 

The vast majority of Fuchsia programs act as *servers*. After startup, they wait in an event loop to receive messages, process those messages (potentially bysending messages to other processes), and then go back to sleep in their eventloop. 紫红色的程序绝大多数都充当“服务器”。启动后，他们在事件循环中等待接收消息，处理这些消息（可能将消息发送给其他进程），然后在其事件循环中返回睡眠状态。

The fundamental building block for event loops in Fuchsia is the [port](/docs/concepts/objects/port.md)object. A thread can sleep in a port using[`zx_port_wait`](/docs/reference/syscalls/port_wait.md).When the kernel wakes up the thread, the kernel provides a *packet*, which is adata structure that describes why the kernel woke up the thread. 紫红色中事件循环的基本构建块是[port]（/ docs / concepts / objects / port.md）对象。线程可以使用[`zx_port_wait`]（/ docs / reference / syscalls / port_wait.md）休眠在端口中。当内核唤醒线程时，内核会提供* packet *，这是一种数据结构，描述了为什么内核唤醒了线程。

Typically, each thread has a single port object in which it sleeps, which a significant amount of code written in your language will need to interact with.Rather than expose the port directly, language mantainers usually providea library that abstracts over a port and provides asynchronous wait operations. 通常，每个线程都有一个休眠的端口对象，与您的语言编写的大量代码将需要与之交互。语言维护者通常提供一个在端口上抽象并提供异步功能的库，而不是直接公开该端口，等待操作。

Most asynchronous wait operations bottom out in [`zx_object_wait_async`](/docs/reference/syscalls/object_wait_async.md). Typically, the `port` and `key`arguments are provided by the library and the `handle` and `signals`arguments are provided by the clients. When establishing a wait, the clientsalso typically provide an upcall (e.g., a closure) for the library to invokewhen the wait completes, at which point the library uses the `key` to recoverthe upcall (e.g., from a hash table). 大多数异步等待操作都在[`zx_object_wait_async`]（/ docs / reference / syscalls / object_wait_async.md）中触底。通常，“ port”和“ key”参数由库提供，而“ handle”和“ signals”参数由客户端提供。建立等待时，客户端通常还会在等待完成后为库提供上行调用（例如关闭），此时库使用``键''来恢复上行调用（例如从哈希表中）。

No additional kernel object is needed to wake a thread up from another thread. You can wake up a thread by simply queuing a user packet to the thread's portusing[zx_port_queue](/docs/reference/syscalls/port_queue.md). 不需要其他内核对象即可将一个线程从另一个线程唤醒。您只需使用[zx_port_queue]（/ docs / reference / syscalls / port_queue.md）将用户数据包排队到线程的端口即可唤醒线程。

 
### Examples  例子 

 
* [async](/zircon/system/ulib/async) (C and C++) * [异步]（/ zircon / system / ulib / async）（C和C ++）
* [fuchsia-async](/garnet/public/rust/fuchsia-async/) (Rust)  * [紫红色异步]（/ garnet / public / rust / fuchsia-async /）（Rust）
* [zxwait](https://fuchsia.googlesource.com/third_party/go/+/master/src/syscall/zx/zxwait/) (Go)  * [zxwait]（https://fuchsia.googlesource.com/third_party/go/+/master/src/syscall/zx/zxwait/）（开始）

 
## FIDL  FIDL 

The Zircon kernel itself largely provides memory management, scheduling, and interprocess communication. Rather than being provided directly by the kernel,the bulk of the system interface is actually provided through interprocesscommunication, typically using [channels](/docs/concepts/objects/channel.md).The protocols used for interprocess communication are defined in[Fuchsia Interface Definition Language (FIDL)](../fidl/README.md). Zircon内核本身在很大程度上提供了内存管理，调度和进程间通信。实际上，不是通过内核直接提供，而是通过进程间通信（通常使用[channels]（/ docs / concepts / objects / channel.md））提供系统接口的大部分。用于进程间通信的协议在[Fuchsia]中定义接口定义语言（FIDL）]（../ fidl / README.md）。

FIDL support for a language typically involves two pieces:  FIDL对一种语言的支持通常涉及两部分：

 
1. A language-specific backend for the FIDL compiler that generates code in the target language. 1. FIDL编译器的特定于语言的后端，它以目标语言生成代码。
2. A support library written in the target language that is used by the code generated by the FIDL compiler. 2.以目标语言编写的支持库，该库由FIDL编译器生成的代码使用。

These pieces are usually not built into the language implementation or runtime. Instead, the libraries are part of the developer's program and versionedindependently from the language runtime. The stable interface between theprogram and the language runtime should be the *system calls* rather than theFIDL protocols so that developers can pick the versions of their FIDLprotocols and the version of their language runtimes independently. 这些部分通常不内置在语言实现或运行时中。相反，这些库是开发人员程序的一部分，并且与语言运行时无关地进行版本控制。程序和语言运行时之间的稳定接口应该是*系统调用*而不是FIDL协议，以便开发人员可以独立选择FIDL协议的版本和语言运行时的版本。

In some cases, the language runtime might need to use FIDL internally. If that happens, prefer to hide this implementation detail from the developer's programif possible in your language. The developer might wish to use newer versions ofthe same FIDL protocols without conflicting with the version used internally bythe language runtime. 在某些情况下，语言运行库可能需要在内部使用FIDL。如果发生这种情况，请尽可能使用您的语言在开发人员的程序中隐藏此实现细节。开发人员可能希望使用相同FIDL协议的更新版本，而不会与语言运行时内部使用的版本冲突。

 
### FIDL compiler backend  FIDL编译器后端 

The [FIDL compiler](/zircon/tools/fidl/) has a single frontend that is used for all languages and multiple backends thatsupport a diverse assortment of languages. The frontend produces a[JSON intermediate format](/docs/development/languages/fidl/reference/json-ir.md)that is consumed by the language-specific backends. [FIDL编译器]（/ zircon / tools / fidl /）具有用于所有语言的单个前端和支持多种语言的多个后端。前端产生一种[JSON中间格式]（/ docs / development / languages / fidl / reference / json-ir.md），该语言专用于后端。

You should create a new backend for the FIDL compiler for your language. The backend can be written in whatever language you prefer. Typically, languagemaintainer choose either Go or the target language. 您应该为您的语言为FIDL编译器创建一个新的后端。后端可以用您喜欢的任何语言编写。通常，Languagemaintainer选择Go或目标语言。

 
 * [fidlgen](/garnet/go/src/fidl/compiler/backend) (C++, Rust, and Go)  * [fidlgen]（/ garnet / go / src / fidl / compiler / backend）（C ++，Rust和Go）
 * [fidlgen_dart](https://fuchsia.googlesource.com/topaz/+/master/bin/fidlgen_dart) (Dart)  * [fidlgen_dart]（https://fuchsia.googlesource.com/topaz/+/master/bin/fidlgen_dart）（飞镖）

 
### Generated code  生成的代码 

The generated FIDL code varies substantially from one language to another. Typically the generated code will contain the following types of code: 生成的FIDL代码从一种语言到另一种语言有很大不同。通常，生成的代码将包含以下类型的代码：

 
* Data structure definitions that represent the data structures defined in the [FIDL language](/docs/development/languages/fidl/reference/language.md). *表示以[FIDL语言]（/ docs / development / languages / fidl / reference / language.md）定义的数据结构的数据结构定义。
* A codec that can serialize and deserialize these data structure into and from the [FIDL wire format](/docs/development/languages/fidl/reference/wire-format/README.md). *编解码器，可以将这些数据结构串行化和反序列化为[FIDL有线格式]（/ docs / development / languages / fidl / reference / wire-format / README.md）。
* Stub objects that represent the server end of a FIDL protocol. Typically, stub object have a *dispatch* method that deserializes a message read from aZircon channel and perform an indirect jump into an implementation of themethod specied by the message's *ordinal*. *代表FIDL协议服务器端的存根对象。通常，存根对象具有* dispatch *方法，该方法反序列化从Zircon通道读取的消息，并间接跳转到消息的* ordinal *指定的方法的实现中。
* Proxy objects that represent the client end of a FIDL protocol. Typically, method calls on proxy objects result in a message being serialized andsent over a Zircon channel. Typically, proxy object have a *dispatch* forevent messages similar to the dispatch method found in stubs for requestmessages. *代表FIDL协议客户端的代理对象。通常，对代理对象的方法调用会导致消息被序列化并通过Zircon通道发送。通常，代理对象具有* dispatch * forevent消息，类似于在请求消息的存根中找到的分发方法。

Some languages offer multiple options for some of these types of generated code. For example, a common pattern is to offer both *synchronous* and *asynchronous*proxy objects. The synchronous proxies make use of[`zx_channel_call`](/docs/reference/syscalls/channel_call.md)to efficiently write a message, block waiting for a response, and then read theresponse, whereas asynchronous proxies use[`zx_channel_write`](/docs/reference/syscalls/channel_write.md),[`zx_object_wait_async`](/docs/reference/syscalls/object_wait_async.md),and[`zx_channel_read`](/docs/reference/syscalls/channel_read.md)to avoid blocking on the remote end of the channel. 对于某些类型的生成代码，某些语言提供了多个选项。例如，一种常见的模式是同时提供* synchronous *和* asynchronous * proxy对象。同步代理使用[`zx_channel_call`]（/ docs / reference / syscalls / channel_call.md）高效地编写消息，阻止等待响应然后读取响应，而异步代理使用[`zx_channel_write`]（ /docs/reference/syscalls/channel_write.md)、[`zx_object_wait_async`](/docs/reference/syscalls/object_wait_async.md）和[`zx_channel_read`]（/ docs / reference / syscalls / channel_read.md）以避免在通道的远端阻塞。

Generally, we prefer to use *asynchronous* code whenever possible. Many FIDL protocols are designed to be used in an asynchronous, feed-forward pattern. 通常，我们希望尽可能使用* asynchronous *代码。许多FIDL协议被设计用于异步，前馈模式。

 
### Support library  支持库 

When designing the generated code for your language, pay particular attention to binary size. Sophisticated program often interact with a large number of FIDLprotocols, each of which might define many data structures and protocols. 在为您的语言设计生成的代码时，请特别注意二进制大小。复杂的程序经常与大量的FIDL协议进行交互，其中每个协议都可以定义许多数据结构和协议。

One important technique for reducing binary size is to factor as much code as possible into a FIDL *support library*. For example, the C bindings, all theserialization and deserialization logic is performed by a routine in a supportlibrary. The generate code contains only a table that describes the wire formatin a compact form. 减小二进制大小的一项重要技术是将尽可能多的代码分解到FIDL *支持库*中。例如，C绑定，所有序列化和反序列化逻辑都是由支持库中的例程执行的。生成代码仅包含一个表格，该表格以紧凑的形式描述了电汇格式。

Typically, the support library is layered on top of the async library, which itself has no knowledge of FIDL. For example, most support libraries contain a*reader* object, which manages the asynchronous waiting and reading operationson channels. The generated code can then be restricted to serialzation,deserialization, and dispatch. 通常，支持库位于异步库的顶部，而异步库本身并不了解FIDL。例如，大多数支持库都包含一个* reader *对象，该对象管理通道的异步等待和读取操作。然后可以将生成的代码限制为序列化，反序列化和分派。

 
 * [C](/zircon/system/ulib/fidl)  * [C]（/ zircon / system / ulib / fidl）
 * [C++](/sdk/lib/fidl/cpp/)  * [C ++]（/ sdk / lib / fidl / cpp /）
 * [Rust](/garnet/public/lib/fidl/rust/fidl)  * [Rust]（/ garnet / public / lib / fidl / rust / fidl）
 * [Dart](https://fuchsia.googlesource.com/topaz/+/master/public/dart/fidl/)  * [Dart]（https://fuchsia.googlesource.com/topaz/+/master/public/dart/fidl/）
 * [Go](https://fuchsia.googlesource.com/third_party/go/+/master/src/syscall/zx/fidl/)  * [开始]（https://fuchsia.googlesource.com/third_party/go/+/master/src/syscall/zx/fidl/）

 
## POSIX-style IO  POSIX风格的IO 

POSIX-style IO operations (e.g., `open`, `close`, `read`, and `write`) are layered on top of FIDL. If your language has C interop, you can use the[FDIO library](/zircon/system/ulib/fdio),which translates familiar POSIX operations into the underlying `fuchsia.io` FIDLprotocol. If your language does not have C interop, you will need to interfacedirectly with `fuchsia.io` to provide POSIX-style IO. POSIX风格的IO操作（例如，“打开”，“关闭”，“读取”和“写入”）位于FIDL之上。如果您的语言具有C语言互操作，则可以使用[FDIO库]（/ zircon / system / ulib / fdio），它将熟悉的POSIX操作转换为基础的“ fuchsia.io” FIDL协议。如果您的语言没有C语言互操作，则需要直接与`fuchsia.io`交互以提供POSIX风格的IO。

