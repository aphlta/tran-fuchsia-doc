 
# FIDL tutorial  FIDL教程 

_Audience: Beginning to intermediate FIDL developers._  _受众：入门级FIDL开发人员。_

[TOC]  [目录]

 
## About this tutorial  关于本教程 

In this tutorial, we present a language-independent introduction to FIDL, followed by language-specific sections that develop the clientand server sides of the examples.At the end of each tutorial, we present additional language-specific referencematerial. 在本教程中，我们将介绍FIDL的语言无关的介绍，然后是开发示例的客户端和服务器端的特定于语言的部分。在每个教程的最后，我们还将提供其他特定于语言的参考资料。

 
# Overview  总览 

While "**FIDL**" stands for "Fuchsia Interface Definition Language," the word itself is commonly used to refer to a lot of different things: “ ** FIDL **”代表“紫红色的界面定义语言”，但该词本身通常用于指代许多不同的事物：

 
*   the infrastructure required for the IPC calls,  * IPC呼叫所需的基础架构，
*   the FIDL language,  * FIDL语言，
*   the FIDL compiler, or  * FIDL编译器，或
*   the generated bindings.  *生成的绑定。

This tutorial describes the steps required to create protocols, make calls, and write server code that uses the FIDL interprocess communication (IPC) system in Fuchsia.We'll also see an overview of the entire workflow required, for both service writersand users (clients). 本教程描述了使用Fuchsia中的FIDL进程间通信（IPC）系统创建协议，进行调用和编写服务器代码所需的步骤，我们还将看到服务编写者和用户（客户端）所需的整个工作流程的概述）。

> Note that the Fuchsia operating system has no innate knowledge of FIDL. > The FIDL bindings use a standard channel communication mechanism in Fuchsia.> The FIDL bindings and libraries enforce a set of semantic behavior and> persistence formats on how that channel is used. >请注意，紫红色操作系统没有FIDL的先天知识。 > FIDL绑定在紫红色中使用标准的通道通信机制。> FIDL绑定和库在如何使用该通道时强制执行一组语义行为和>持久性格式。

For details on the design and implementation of FIDL, see the [main FIDL page](../README.md) 有关FIDL的设计和实现的详细信息，请参见[FIDL主页]（../ README.md）

 
## Example source code  示例源代码 

Most examples used in this tutorial are located in Garnet at: [//garnet/examples/fidl/](/garnet/examples/fidl/) 本教程中使用的大多数示例都位于Garnet中，位于：[// garnet / examples / fidl /]（/ garnet / examples / fidl /）

Language-specific examples may be found in other directories; this is indicated as appropriate. 在其他目录中可以找到特定于语言的示例。这被指示为适当的。

 
## FIDL in a nutshell  简而言之FIDL 

The main job of FIDL is to allow diverse clients and services to interoperate. Client diversity is aided by decoupling the implementation of theIPC mechanism from its definition, and is simplified by automaticcode generation. FIDL的主要工作是允许各种客户端和服务进行互操作。通过将IPC机制的实现与它的定义解耦来辅助客户端多样性，并通过自动代码生成来简化。

The FIDL language provides a familiar (though simplified) C-like declaration syntax that allows the service provider to exactly define their protocols.Basic data types, like integers, floats, and strings,can be organized into more complex aggregate structures and unions.Fixed arrays and dynamically sized vectors can be constructed from boththe basic types and the aggregate types, and these can all be combinedinto even more complex data structures. FIDL语言提供了一种熟悉的（尽管简化了）类似于C的声明语法，该语法使服务提供商可以精确定义其协议。基本数据类型（例如整数，浮点数和字符串）可以组织为更复杂的聚合结构和联合。数组和动态大小的矢量可以从基本类型和聚合类型中构造，并且都可以组合成更复杂的数据结构。

Due to the number of client implementation target languages (C, C++, Rust, Dart, and so on), we don't want to burden the developer ofthe service with providing a protocol implementation for each and every one. 由于客户端实现目标语言（C，C ++，Rust，Dart等）的数量众多，我们不想为服务的开发人员负担为每一种提供协议实现的负担。

This is where the FIDL toolchain comes in. The developer of the service creates just one `.fidl` definition file,which defines the protocol.Using this file, the FIDL compiler then generates client and server codein any of the supported target languages. 这就是FIDL工具链的来源。服务的开发人员仅创建一个`.fidl`定义文件，该文件定义了协议。FIDL编译器使用此文件以任何受支持的目标语言生成客户端和服务器代码。

![Figure: server written in C++ talks to clients written in multiple languages](fidl_architecture.png) ！[图：用C ++编写的服务器与使用多种语言编写的客户端进行对话]（fidl_architecture.png）

In many cases, there will only be one implementation of the server (for example, the particular service might be implemented in C++), whereas there could be any numberof implementations of the client, in a multitude of languages. 在许多情况下，只有一种服务器实现（例如，特定的服务可能以C ++实现），而客户端可以有多种语言，可以有多种实现。

 
# FIDL architecture  FIDL体系结构 

From a developer's point of view, the following are the main components:  从开发人员的角度来看，以下是主要组件：

 
*   FIDL definition file &mdash; this is a text file (ending in `.fidl` by convention) that defines the values, and protocols (methods with their parameters), * FIDL定义文件-这是一个文本文件（按约定以.fidl结尾），定义了值和协议（带有参数的方法），
*   client code &mdash; generated by the FIDL compiler (`fidlc`) toolchain for each specific target language, and *客户端代码mdash; FIDL编译器（`fidlc`）工具链针对每种特定目标语言生成的；以及
*   server code &mdash; also generated by the FIDL compiler toolchain.  *服务器代码mdash;也由FIDL编译器工具链生成。

We'll look at the client and server code generically in this chapter, and then in language specific detail in following chapters. 在本章中，我们将大致介绍客户端和服务器代码，然后在以下各章中，以特定于语言的细节进行介绍。

 
## FIDL definition  FIDL定义 

The FIDL definition file defines the protocol. As a very simple example, consider an "echo" service &mdash; whatever the client sendsto the server, the server just echoes back to the client. FIDL定义文件定义协议。作为一个非常简单的示例，考虑一个“回声”服务模型。不论客户端发送到服务器的内容如何，​​服务器都将回显到客户端。

> Line numbers have been added for clarity and are not part of the `.fidl` file.  >为了清楚起见，添加了行号，这些行号不属于.fidl文件。

```fidl
1   library fidl.examples.echo;
2
3   [Discoverable]
4   protocol Echo {
5       EchoString(string? value) -> (string? response);
6   };
```
 

Let's go through it line by line.  让我们逐行处理它。

**Line 1:** The `library` keyword is used to define a namespace for this protocol. FIDL protocols in different libraries might have the same name, so the namespaceis used to distinguish amongst them. **第1行：**`library`关键字用于定义此协议的名称空间。不同库中的FIDL协议可能具有相同的名称，因此使用命名空间来区分它们。

**Line 3:** The `[Discoverable]` [**attribute**][attributes] indicates that the protocol that follows should be made available for clients to connect to. **第3行：** [[Discoverable]] [** attribute **] [attributes]指示应遵循以下协议，以使客户端可以连接。

**Line 4:** The `protocol` keyword introduces the name of the protocol, here it's called `Echo`.  **第4行：**`protocol`关键字介绍了协议的名称，在这里称为`Echo`。

**Line 5:** The method, its parameters, and return values. There are two unusual aspects of this line: **第5行：**方法，其参数和返回值。此行有两个不同寻常的方面：

 
*   Note the declaration `string?` (for both `value` and `response`). The `string` part indicates that the parameters are strings (sequences ofcharacters), while the question mark indicates that the parameter is optional. *注意声明“ string”（对于“ value”和“ response”）。字符串部分指示参数是字符串（字符序列），而问号指示参数是可选的。
*   The `->` part indicates the return, which appears after the method declaration, not before. Unlike C++ or Java, a method can return multiple values. *`->`部分表示返回值，它出现在方法声明之后，而不是之前。与C ++或Java不同，方法可以返回多个值。

The above FIDL file, then, has declared one protocol, called `Echo`, with one method, called `EchoString`, that takes a nullable string and returns a nullable string. 然后，上面的FIDL文件声明了一个名为“ Echo”的协议，并带有一个名为“ EchoString”的方法，该方法采用可为空的字符串并返回可为空的字符串。

 
## Aggregate data types  汇总数据类型 

The simple example above used just one data type, the `string` as both the input to the method as well as the output. 上面的简单示例仅使用一种数据类型，即“字符串”作为方法的输入以及输出。

The data types are very flexible:  数据类型非常灵活：

```fidl
struct MyRequest {
    uint32 serial;
    string key;
    vector<uint32> options;
};
```
 

The above declares a structure called `MyRequest` with three members: an unsigned 32-bit integer called `serial`, a string called `key`, and a vector of unsigned 32-bitintegers called `options`. 上面的代码声明了一个具有三个成员的名为MyRequest的结构：一个无符号的32位整数（串行），一个字符串（称为key）以及一个无符号的32位整数向量（称为options）。

 
## Messaging  讯息传递 

In order to understand FIDL's messaging, we need to break things up into two layers, and clarify some definitions. 为了理解FIDL的消息传递，我们需要将事情分为两层，并阐明一些定义。

At the bottom (the operating system layer), there's an asynchronous communications scheme geared towards independent progress of a **sender** and a **receiver**: 在底层（操作系统层），有一个异步通信方案，旨在使发送方和接收方独立进行：

 
*   **sender** &mdash; the party that originates a message,  * **发送者**-发出消息的一方，
*   **receiver** &mdash; the party that receives a message,  * **接收器**-收到消息的一方，

Sending a message is a non-blocking operation: the sender sends the message, and is then free to continue processing, regardless of what the receiver is doing. 发送消息是一种非阻塞操作：发送者发送消息，然后可以自由地继续处理，而不管接收者在做什么。

A receiver can, if it wants to, block in order to wait for a message.  接收方可以根据需要阻塞以等待消息。

The top layer implements FIDL messages, and uses the bottom (asynchronous) layer. It deals with **client**s and **server**s: 顶层实现FIDL消息，并使用底层（异步）层。它处理** client **和** server ** s：

 
*   **client** &mdash; the party that is making a request (of a server),  * **客户** mdash; （服务器的）请求方，
*   **server** &mdash; the party that is processing a request (on behalf of a client).  * **服务器** mdash;处理请求的一方（代表客户）。

> The terms "sender" and "receiver" make sense when we're discussing the messages > themselves &mdash; the underlying communications scheme isn't concerned about> the roles that we've assigned to the parties, just that one is sending and one> is receiving.>> The terms "client" and "server" make sense when we're discussing the roles that> the parties play.> In particular, a client can be a sender at one time, and a receiver at a> different time; same for the server. >当我们讨论消息本身时，术语“发送者”和“接收者”才有意义。基本的通信方案不关心>我们分配给各方的角色，只是一个正在发送而一个正在接收。>>在我们讨论时，术语“客户端”和“服务器”有意义尤其是，一个客户可以同时是发送者，而在不同时间可以是接收者；服务器也一样。

Practically speaking, in the context of a client / server interaction, that means that there are several models: 实际上，在客户机/服务器交互的上下文中，这意味着有几种模型：

 
1.  **blocking call** &mdash; client sends to server, waits for reply  1. **阻止通话** –客户端发送到服务器，等待回复
2.  **fire and forget** &mdash; client sends to server, doesn't expect reply  2. **忘记并忘记** –客户端发送到服务器，不希望回复
3.  **callback** or **async call** &mdash; client sends to server, but doesn't block; a reply is delivered asynchronously some time later 3. **回拨**或**异步通话**-客户端发送到服务器，但不阻塞；一段时间后异步发送回复
4.  **event** &mdash; server sends to client, without the client having asked for data  4. ** event ** mdash;服务器发送给客户端，而客户端不要求数据

The first is synchronous, the rest are asynchronous. We'll discuss these in order. 第一个是同步的，其余的是异步的。我们将按顺序讨论这些内容。

 
### Client sends to server, waits for a reply  客户端发送到服务器，等待回复 

This model is the traditional "blocking call" or "function call" available in most programming languages, except that the invocation is done over a channel, and thuscan fail due to transport level errors. 该模型是大多数编程语言中可用的传统“阻塞调用”或“功能调用”，除了调用是通过通道完成的，因此可能由于传输级别错误而失败。

From the point of view of the client, it consists of a call that blocks, while the server performs some processing. 从客户端的角度来看，它由阻塞的调用组成，而服务器执行一些处理。

![Figure: client and server](blocking.png)  ！[图：客户端和服务器]（blocking.png）

Here's a step-by-step description:  以下是分步说明：

 
1.  A client makes a call (optionally containing data) and blocks.  1.客户端进行呼叫（可选包含数据）并阻止。
2.  The server receives the client's call (and optional data), and performs some amount of processing. 2.服务器接收到客户端的呼叫（和可选数据），并执行一些处理。
3.  At the server's discretion, it replies to the client (with optional data).  3.服务器可以自行决定是否回复客户端（带有可选数据）。
4.  The server's reply causes the client to unblock.  4.服务器的答复使客户端解除阻止。

To implement this synchronous messaging model over an asynchronous messaging scheme is simple.Recall that both the client-to-server and server-to-client message transfersare, at the bottom layer in the protocol, asynchronous.The synchronization happens at the client end, by having the client block untilthe server's message arrives. 要通过异步消息传递方案实现此同步消息传递模型很简单，请记住，客户端到服务器和服务器到客户端的消息传输都是在协议的底层异步进行的，同步发生在客户端，通过使客户端阻塞直到服务器的消息到达。

Basically, in this model, the client and server have come to an agreement:  基本上，在此模型中，客户端和服务器已达成协议：

 
*   data flow is initiated by the client,  *数据流是由客户端发起的，
*   the client shall have at most only one message outstanding,  *客户最多只能发送一条消息，
*   the server shall send a message to the client only in response to a client's message  *服务器仅应响应客户的消息，才向客户发送消息
*   the client shall wait for the server's response before continuing.  *客户端应在继续之前等待服务器的响应。

This blocking model is commonly used where the client needs to get the reply to its current request before it can continue. 此阻塞模型通常用于客户端需要继续对其当前请求的答复的情况。

For example, the client may request data from the server, and not be able to do any other useful processing until that data arrives. 例如，客户端可能从服务器请求数据，并且在数据到达之前无法进行任何其他有用的处理。

Or, the client may need to perform steps in a specific order, and must therefore ensure that each step completes before initiating the next one.If an error occurs, the client may need to perform corrective actions that dependon how far the operation has proceeded &mdash; another reason to be synchronizedto the completion of each step. 或者，客户可能需要按照特定顺序执行步骤，因此必须确保在启动下一个步骤之前完成每个步骤。如果发生错误，则客户可能需要根据操作进行了多长时间采取纠正措施。 ;同步到每个步骤完成的另一个原因。

 
### Client sends to server, no reply  客户端发送到服务器，无回复 

This model is also known as "fire and forget." In it, the client sends the message to the server. and then carries onwith its operation.In contrast to the blocking model, the client *does not* block,*nor does it expect a response*. 此模型也称为“失火”。在其中，客户端将消息发送到服务器。与阻塞模型相反，客户端*不*阻塞，*也不希望响应*。

This model is used in cases where the client doesn't need to (or cannot) synchronize to the processing of its request. 如果客户端不需要（或不能）与其请求的处理同步，则使用此模型。

![Figure: Fire and Forget; client sends to server but doesn't expect replies](faf.png) ！！！！客户端发送到服务器但不期望回复]（faf.png）

The classic example is a logging system. The client sends logging information to the logging server (circles "1"and "2" in the diagram above), but has no reason to block.A lot of things can go wrong at the server end: 经典示例是日志记录系统。客户端将日志记录信息发送到日志记录服务器（在上图中的圆圈“ 1”和“ 2”），但是没有理由阻止。在服务器端，很多事情可能会出错：

 
1. the server is busy and can't handle the write request at this moment,  1.服务器忙，目前无法处理写入请求，
2. the media is full and the server can't write the data,  2.介质已满，服务器无法写入数据，
3. the server has encountered a fault,  3.服务器遇到故障，
4. and so on.  4.依此类推。

However, the client isn't in a position to do anything about those problems, so blocking would just create more problems. 但是，客户无权对这些问题采取任何措施，因此阻止只会带来更多问题。

 
### Client sends to server, but doesn't block  客户端发送到服务器，但不阻止 

This model, and the next one ("server sends to client, without client asking for data") are similar. 此模型与下一个模型（“服务器发送给客户端，而无需客户端请求数据”）相似。

In the present model, the client sends a message to a server, but doesn't block. However, the client expects some kind of response from the server, but thekey here is that it's not *synchronous* with the request. 在当前模型中，客户端将消息发送到服务器，但不会阻塞。但是，客户端希望服务器发出某种响应，但是关键是它与请求不是“同步”的。

This allows great flexibility in the client / server interaction.  这在客户端/服务器交互中提供了极大的灵活性。

While the synchronous model forces the client to wait until the server replies, the present model frees the client to do something else while the server isprocessing the request: 同步模型强制客户端等待服务器回复之前，本模型在服务器处理请求时释放客户端做其他事情：

![Figure: client sends to server but doesn't block until later](async.png)  ！[图：客户端发送到服务器，但直到稍后才阻止]（async.png）

The subtle difference in this diagram vs. the similar one above is that after circle "1" the client is *still running*.The client chooses when to give up CPU; it's not synchronous with the message. 与上图类似，该图中的细微差别在于，在圆圈“ 1”之后，客户端*仍在运行*。客户端选择何时放弃CPU；它与消息不同步。

There are actually two sub-cases here &mdash; one in which the client gets just one response, and another in which the client can get multiple responses.(The one where the client gets zero responses is the "fire and forget" model,which we discussed earlier.) 实际上，这里有两个子情况。一个在其中客户端仅获得一个响应，而另一个在客户端中可以获得多个响应。（一个在客户端获得零响应的是“解雇”模型，我们在前面已经讨论过。）

 
#### Single request, single response  单一要求，单一回应 

The single response case is the closest to the synchronous model: the client sends a message, and eventually, the server replies.You'd use this model instead of multi-threading, for example, when you know thatthe client could be doing useful work while waiting for the server's reply. 单一响应情况最接近同步模型：客户端发送一条消息，最终服务器回复。例如，当您知道客户端可能正在做有用的工作时，可以使用此模型而不是多线程。在等待服务器的回复时。

 
#### Single request, multiple response  单个请求，多个响应 

The multiple response case can be used in a "subscription" model. The client's message "primes" the server, for example, requesting notificationwhenever something happens. 可以在“订阅”模型中使用多重响应的情况。客户端的消息“启动”服务器，例如，无论何时发生什么，都请求通知。

The client then goes about its business.  然后，客户开始其业务。

Some time later, the server notices that the condition that the client is interested in has happened, and thus sends the client a message.From a client / server point of view, this message is a "reply", with the clientreceiving it asynchronously to its request. 一段时间后，服务器注意到发生了客户端感兴趣的情况，因此向客户端发送了一条消息。从客户端/服务器的角度来看，此消息是“回复”，客户端异步接收到它的要求。

![Figure: client sends to server, server replies multiple times](async-multiple.png)  ！[图：客户端发送到服务器，服务器多次答复]（async-multiple.png）

There's no reason why the server couldn't send another message when another event of interest occurs; this is the "multiple response" version of the model.Note that the second (and subsequent) responses are sent *without* the clientsending any additional messages. 当发生其他感兴趣的事件时，服务器没有理由无法发送其他消息。这是模型的“多个响应”版本。请注意，第二个（和后续）响应是在没有发送任何其他消息的客户端的情况下发送的。

> Note that the client doesn't *need* to wait for the server to send it a message. > In the diagram above, we showed the client in the blocked state before circle> "3" &mdash; the client could just as well have been running. >请注意，客户端*不需要*等待服务器向其发送消息。 >在上图中，我们在圆圈>“ 3”之前显示了处于阻塞状态的客户端；客户端也可能一直在运行。

 
### Server sends to client, without client asking for data  服务器发送给客户端，而无需客户端请求数据 

This model is also known as the "event" model.  此模型也称为“事件”模型。

![Figure: unsolicited messages from a server to a client](event.png)  ！[图：从服务器到客户端的不请自来的消息]（event.png）

In it, a client prepares to receive messages from a server, but doesn't know when to expect them &mdash; the messages are not only asynchronous to the client,but are also (from a client / server point of view) "unsolicited", in that theclient didn't explicitly request them (like it did in the previous model, above). 在其中，客户端准备从服务器接收消息，但不知道何时期望它们。消息不仅与客户端异步，而且（从客户端/服务器的角度来看）也是“未经请求的”，因为客户端没有明确地请求它们（就像上面的上一个模型一样）。

The client designates a function (the "event handling function") to be called when messages arrive from the server, but otherwise continues about its business. 客户端指定消息从服务器到达时要调用的功能（“事件处理功能”），否则将继续其业务。

At the server's discretion (circles "1" and "2" in the diagram above), messages are sent asynchronously to the client, and handled by the client's designatedfunction. 根据服务器的判断（上图中的圆圈“ 1”和“ 2”），消息异步发送到客户端，并由客户端指定的功能处理。

Note that the client may already be running when a message is sent (as in circle "1"), or the client may have nothing to do and be waiting for amessage to be sent (as in circle "2"). 请注意，发送消息时客户端可能已经在运行（如圆圈“ 1”），或者客户端可能无事可做，正在等待发送消息（如圆圈“ 2”）。

> It is not a requirement that the client be waiting for a message.  >不需要客户端等待消息。

 
### Asynchronous messaging complexity  异步消息传递的复杂性 

Breaking up asynchronous messaging into the above (somewhat arbitrary) categories is meant to show typical usage patterns, but isn't meant to be exhaustive. 将异步消息传递划分为以上（某种程度上是任意的）类别是为了显示典型的使用模式，但并不意味着详尽无遗。

In the most general case of asynchronous messaging, you have zero or more client messages loosely associated with zero or more server replies.It's this "loose association" that adds the complexity in terms of your designprocess. 在异步消息传递的最一般情况下，您零个或多个客户机消息与零个或多个服务器答复松散地关联。正是这种“松散关联”增加了设计过程的复杂性。

 
## IPC models in FIDL  FIDL中的IPC模型 

Now that we have an understanding of the IPC models and how they interact with FIDL's asynchronous messaging, let's see how they're defined. 现在我们已经了解了IPC模型以及它们如何与FIDL的异步消息传递交互，让我们看看它们是如何定义的。

We'll add the other models (fire and forget, and async call) to the protocol definition file: 我们将其他模型（即发即忘和异步调用）添加到协议定义文件中：

 

```fidl
1   library fidl.examples.echo;
2
3   [Discoverable]
4   protocol Echo {
5       EchoString(string? value) -> (string? response);
6       SendString(string? value);
7       -> ReceiveString (string? response);
8   };
```
 

**Line 5** is the `EchoString` method that we discussed above &mdash; it's a traditional function call message, where the client calls `EchoString` withan optional string, and then blocks, waiting for the server to reply withanother optional string. **第5行**是我们在前面的mdash中讨论的`EchoString`方法；这是传统的函数调用消息，其中客户端使用可选字符串调用`EchoString`，然后阻塞，等待服务器用另一个可选字符串进行回复。

**Line 6** is the `SendString` method. It does not have the `->` return declaration &mdash; that makes it into a"fire and forget" model (send only), because we've told the FIDL compiler thatthis particular method does not have a return associated with it. **第6行**是`SendString`方法。它没有`->`返回声明mdash；使其成为“即发即弃”模型（仅发送），因为我们已经告知FIDL编译器该特定方法没有与之关联的返回值。

> Note that it's not the lack of return **parameters**, but rather the lack of > return **declaration** that's the key here &mdash; putting "`-> ()`"> after `SendString` would change the meaning from declaring a fire-and-forget> style method to declaring a function call style method that doesn't have any> return arguments. >请注意，这不是缺少return **参数**而是缺少> return ** declaration **的关键所在。将“`->（）`”>放置在`SendString`之后将改变含义，从声明“即弃即忘”样式方法到声明没有任何>返回参数的函数调用样式方法。

**Line 7** is the `ReceiveString` method. It's a little different &mdash; it doesn't have the method name in the firstpart, but rather it's given after the `->` operator.This tells the FIDL compiler that this is an "async call" model declaration. **第7行**是`ReceiveString`方法。有点不同。它在第一部分中没有方法名称，而是在`->运算符之后给出。这告诉FIDL编译器这是一个“异步调用”模型声明。

 
# Client implementation  客户实施 

Regardless of the target language, the `fidlc` FIDL compiler generates client code that has the following basic structure. 不管目标语言是什么，`fidlc` FIDL编译器都会生成具有以下基本结构的客户端代码。

The first part consists of the administration and background handling, and consists of: 第一部分包括管理和后台处理，包括：

 
1. some means of connecting to the server is provided  1.提供了一些连接到服务器的方法
2. an asynchronous ("background") message handling loop is started  2.启动异步（“后台”）消息处理循环
3. async call style and event style methods, if any, are bound to the message loop 3.异步调用样式和事件样式方法（如果有）绑定到消息循环

The second part consists of implementations of the traditional function call or fire and forget style methods, as appropriate for the target language.Generally speaking, this consists of: 第二部分包括适用于目标语言的传统函数调用或即发即弃样式方法的实现，通常包括：

 
1. creating a callable API and declarations  1.创建一个可调用的API和声明
2. generating code for each API that marshals the data from the call into a FIDL formatted buffer suitable for transmission to the server 2.为每个API生成代码，以将来自调用的数据封送到FIDL格式的缓冲区中，以适合传输到服务器
3. generating code to transmit the data to the server  3.生成代码以将数据传输到服务器
4. in the case of function call style calls, generating code to:  4.对于函数调用样式调用，生成代码以：
    1. wait for the response from the server  1.等待服务器的响应
    2. unmarshal the data from the FIDL formatted buffer, and  2.从FIDL格式的缓冲区中解组数据，然后
    3. return the data via the API function.  3.通过API函数返回数据。

Obviously, the exact steps may vary due to language implementation differences, but that's the basic outline. 显然，由于语言实现的差异，确切的步骤可能会有所不同，但这只是基本概述。

 
# Server implementation  服务器实施 

The `fidlc` FIDL compiler can also generate server code for a given target language. Just like the client code, this code has a common structure regardlessof the target language. The code: FIDLC FIDL编译器还可以为给定的目标语言生成服务器代码。就像客户端代码一样，此代码具有通用的结构，而与目标语言无关。代码：

 
1. creates an object which clients can connect to,  1.创建一个客户端可以连接的对象，
2. starts a main processing loop, which:  2.启动一个主处理循环，该循环：
    1. waits for messages  1.等待消息
    2. processes messages by calling out to the implementation functions  2.通过调出实现功能来处理消息
    3. if specified, issues an asynchronous call back to the client to return the output 3.如果指定，则向客户端发出异步调用以返回输出

In the next chapters, we'll see the details of each language's implementation of the client and server code. 在下一章中，我们将看到每种语言的客户端和服务器代码实现的详细信息。

 
# Languages  语言能力 

Currently, tutorials are available in the following languages:  当前，教程提供以下语言的版本：

 
*   [C](tutorial-c.md)  * [C]（tutorial-c.md）
*   [Low-Level C++](tutorial-llcpp.md)  * [低级C ++]（tutorial-llcpp.md）
*   [High-Level C++](tutorial-cpp.md)  * [高级C ++]（tutorial-cpp.md）
*   [Dart](tutorial-dart.md)  * [Dart]（tutorial-dart.md）
*   [Rust](tutorial-rust.md)  * [锈]（tutorial-rust.md）

Consult the [C Family Comparison](c-family-comparison.md) document for an overview of the similarities and differences between the C, Low-Level C++,and High-Level C++ bindings. 请查阅[C系列比较]（c-family-comparison.md）文档，以概述C，低级C ++和高级C ++绑定之间的异同。

<!-- xrefs --> [attributes]: ../reference/attributes.md <！-外部参照-> [attributes]：../reference/attributes.md

