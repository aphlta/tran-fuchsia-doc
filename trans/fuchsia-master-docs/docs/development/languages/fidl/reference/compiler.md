 
# FIDL Compiler  FIDL编译器 

This document contains these sections:  本文档包含以下部分：

 
* Description of the [command-line interface to the FIDL compiler](#compiler-interface).This section is for users of the compiler. * [FIDL编译器的命令行界面]（编译器界面）的说明。本节适用于编译器用户。
* Overview of the [internals of the compiler frontend](#compiler-internals).This section is for developers of the compiler or FIDL tools. * [编译器前端的内部]（compiler-internals）概述。本部分适用于编译器或FIDL工具的开发人员。

For more information about FIDL's overall purpose, goals, and requirements, see [Overview](../intro/README.md). 有关FIDL总体目的，目标和要求的更多信息，请参见[概述]（../ intro / README.md）。

 
## Compiler Interface {#compiler-interface}  编译器接口{compiler-interface} 

 
### Overview  总览 

The FIDL compiler is split into a frontend and a number of backends. The compiler processes one library at a time. The frontend consumes the FIDL declarations for the library (as well as for alltransitive dependencies), performs semantic analysis, and outputs an intermediate representation ofthe library. The backends consume the intermediate representation and generate language-specificbindings for the library. FIDL编译器分为一个前端和多个后端。编译器一次处理一个库。前端使用库的FIDL声明（以及所有传递依赖项），执行语义分析并输出库的中间表示形式。后端使用中间表示并为库生成特定于语言的绑定。

 
### Frontend  前端 

The frontend is a command-line program named `fidlc`. The `fidlc` compiler has these flags:  前端是一个名为“ fidlc”的命令行程序。 fidlc`编译器具有以下标志：

 
* `--c-header HEADER_PATH`. If present, this flag instructs `fidlc` to output a C header at the given path. The C header generation could have been implemented as a C backend, but for practicalreasons, the C header generation is integrated directly into the frontend. *`--c-header HEADER_PATH`。如果存在，该标志指示`fidlc`在给定路径输出C头。 C头生成本来可以作为C后端实现，但出于实际原因，C头生成直接集成到了前端中。

 
* `--tables TABLES_PATH`. If present, this flag instructs `fidlc` to output coding tables at the given path. The coding tables are required to encode and decode messages from the C and C++bindings. *`--tables TABLES_PATH`。如果存在，该标志指示`fidlc`在给定路径下输出编码表。需要编码表来对来自C和C ++绑定的消息进行编码和解码。

 
* `--json JSON_PATH`. If present, this flag instructs `fidlc` to output the library's intermediate representation at the given path. The intermediate representation is JSON that conforms to [aparticular schema][schema]. The intermediate representation is used asinput to the various backends. *`--json JSON_PATH`。如果存在，该标志指示`fidlc`在给定路径下输出库的中间表示。中间表示是符合[aparticular schema] [schema]的JSON。中间表示用作各种后端的输入。

 
* `--name LIBRARY_NAME`. If present, this flag instructs `fidlc` to validate that the library being compiled has the given name. This flag is useful to cross-check between the library'sdeclaration in a build system and the actual contents of the library. *`--name LIBRARY_NAME`。如果存在，此标志指示`fidlc`验证正在编译的库具有给定的名称。该标志对于在构建系统中库的声明和库的实际内容之间进行交叉检查很有用。

 
* `--files [FIDL_FILE...]...`. Each `--file [FIDL_FILE...]` chunk of arguments describes a library, all of which must share the same top-level library name declaration. Libraries must bepresented in dependency order, with later libraries able to use declarations from precedinglibraries but not vice versa. Output is only generated for the final library, not for each ofits dependencies. *`-文件[FIDL_FILE ...] ...`。每个`--file [FIDL_FILE ...]`参数块都描述一个库，所有这些库必须共享相同的顶级库名称声明。库必须以依赖关系顺序表示，以后的库能够使用前一个库的声明，反之亦然。仅为最终库生成输出，而不是为其每个依赖项生成输出。

All of the flags can also be provided through a response file, denoted as `@responsefile`. The contents of the file at `responsefile` will be interpreted as a whitespace-delimited list ofarguments. Response files cannot be nested, and must be the only argument. 所有标志也可以通过响应文件提供，表示为“ @responsefile”。 “ responsefile”中文件的内容将被解释为以空格分隔的参数列表。响应文件不能嵌套，并且必须是唯一的参数。

 
### Backend  后端 

The backend is a command-line program named `fidlgen`. The `fidlgen` compiler has these flags:  后端是一个名为“ fidlgen”的命令行程序。 fidlgen编译器具有以下标志：

 
* `--json`. Required. The path to the intermediate representation of the library. The intermediate representation is JSON that conforms to [a particularschema][schema]. *`--json`。需要。库的中间表示形式的路径。中间表示是符合[特定模式] [模式]的JSON。

 
* `--generators`. Required. A comma-separated list of generators to run on the given library. The following generators are supported: `cpp`, `go`, `dart`, and `rust`. *`-发电机`。需要。在给定库上运行的以逗号分隔的生成器列表。支持以下生成器：`cpp`，`go`，`dart`和`rust`。

 
* `--output-base`. Required. The base file name for files generated by this generator. The generator creates files by adding extensions to this file name. For example, the `cpp`backend generates two files, one with the `.h` extension and another with the `.cc` extension. *`--output-base`。需要。此生成器生成的文件的基本文件名。生成器通过向该文件名添加扩展名来创建文件。例如，cpp后端生成两个文件，一个文件扩展名为.h，另一个文件扩展名为.cc。

 
* `--include-base`. Required. The base directory relative to which C and C++ `#include` directives should be computed. For example, when the `cpp` backend generates an `#include`directive to reference the `.h` file from the `.cc` file, the backend creates the `#include`path relative to this directory. *`--include-base`。需要。计算C和C ++ include指令所相对的基本目录。例如，当cpp后端从.cc文件中生成引用包含.h文件的include伪指令时，后端将创建相对于该目录的include路径。

 
### Limitations  局限性 

For the `cpp` backend, the generated `.h` file must be includeable as `#include <fuchsia/cpp/$LIBRARY_NAME.h>`, where `$LIBRARY_NAME` is the name of the corresponding FIDLlibrary. Typically, that means that the `--output-base` flag will have the value`$INCLUDE_BASE/fuchsia/cpp/$LIBRARY_NAME`, where `$INCLUDE_BASE` is the value of the`--include-base` flag. 对于`cpp`后端，生成的`.h`文件必须可包含为`include <fuchsia / cpp / $ LIBRARY_NAME.h>`，其中$ LIBRARY_NAME`是相应FIDLlibrary的名称。通常，这意味着--output-base标志的值将为$ INCLUDE_BASE / fuchsia / cpp / $ LIBRARY_NAME，其中$ INCLUDE_BASE是--include-base标志的值。

 
## Compiler Internals {#compiler-internals}  编译器内部{compiler-internals} 

 
### Overview  总览 

The main inputs to the compiler are the arguments to the `--files` flags, which describe a list of files grouped by library. The compiler parses each file individually to obtain a parse tree foreach file: 编译器的主要输入是`--files'标志的参数，该标志描述了按库分组的文件列表。编译器分别解析每个文件以获得每个文件的解析树：

 
1. Each file is loaded into a [`SourceFile`](#sourcefile), which owns the buffer backing the file  1.每个文件都被加载到[`SourceFile`]（sourcefile）中，该文件拥有支持文件的缓冲区
2. The compiler initializes a [`Lexer`](#lexing), which takes the `SourceFile` as an argument to its constructor. This class exposes a `Lex()` method, which returns the next [`Token`](#token)in the file; it can be called repeatedly to get the sequence of `Token`s in the file. 2.编译器初始化一个[`Lexer`]（lexing），后者将`SourceFile`作为其构造函数的参数。此类公开一个Lex（）方法，该方法返回文件中的下一个[`Token`]（token）；可以重复调用它以获取文件中Token的序列。
3. The compiler uses the `Lexer` to initialize a [`Parser`](#parsing) and then calls the `Parse()` method which constructs a parse tree. The code refers to parse trees as a raw AST. This functionreturns a `raw::File` which is the class representing the root node of the raw AST. 3.编译器使用Lexer来初始化一个Parser解析（parsing），然后调用Parse（）方法来构造一个解析树。该代码将解析树称为原始AST。此函数返回一个“ raw :: File”，该类代表原始AST的根节点。
4. Once the compiler has parsed each file into a parse tree, it then groups the parse trees into a single AST (referred to in the code as a flat AST) for each library. The root of this flat ASTis a `flat::Library`. 4.编译器将每个文件解析为一个解析树后，然后将解析树分为每个库的单个AST（在代码中称为纯AST）。这个平面AST的根是一个`flat :: Library`。
   * For each library, the compiler traverses every `raw::File` parse tree corresponding to that library, converting `raw::` nodes to their `flat::` counterparts. For example, a`raw::StructDeclaration` becomes a `flat::Struct`, and a `raw::Constant` becomes a`flat::Constant`. The converted `flat::` AST nodes are then stored under a single`flat::Library`. Initially these flat AST nodes contain the same information as the raw ASTnodes, but they also contain fields such as a `value` field for values and a `typeshape` fieldfor types which are later set during the compilation step. *对于每个库，编译器遍历与该库对应的每个`raw :: File`解析树，将`raw ::`节点转换为它们的`flat ::`副本。例如，raw :: StructDeclaration变为flat :: Struct，而raw :: Constant变为flat：Constant。然后将转换后的`flat ::`AST节点存储在单个`flat :: Library'下。最初，这些平面AST节点包含与原始ASTnode相同的信息，但是它们还包含诸如值的“值”字段和类型的“ typeshape”字段之类的字段，这些字段随后在编译步骤中进行设置。
5. Once the AST has been fully initialized, the compiler evaluates constants and determines the memory alignment and size information for the declared types. 5. AST完全初始化后，编译器将评估常量并确定已声明类型的内存对齐和大小信息。

Note: One of the key distinction between raw and flat ASTs is that each raw tree represents a single file, whereas each flat tree represents a single FIDL library which may contain multiplefiles. 注意：原始AST与平面AST之间的主要区别之一是，每个原始树代表一个文件，而每个平面树代表一个FIDL库，其中可能包含多个文件。

Finally, we end up with a flat AST that is processed and ready for backend generation either to C bindings or to a JSON IR. 最后，我们得到一个经过处理的平面AST，并准备用于C绑定或JSON IR的后端生成。

 
### Lexing {#lexing}  乐兴{lexington} 

The `Lexer` works primarily by keeping track of two `char *` pointer into the file data. The `current_` pointer marks the current location that the class is at. The`token_start_` pointer marksthe start of the lexeme that is currently being worked on. Each time the `Lex()` method is called,the `current_` pointer is advanced until a complete lexeme has been traversed. Then, a `Token` isconstructed using the data in between the two pointers. `Lexer`主要通过跟踪两个`char *`指针进入文件数据来工作。 “ current_”指针标记该类所在的当前位置。 “ token_start_”指针标记了当前正在处理的词素的开始。每次调用Lex（）方法时，都会前进current_指针，直到遍历完整的词素为止。然后，使用两个指针之间的数据构造一个“令牌”。

The lexer also keeps track of a third `previous_end_` pointer so it can get the data between lexemes (generally whitespace) when it constructs the `Token`. This example shows of how thepointers change during a call to `Lex()` on the short FIDL snippet `const bool flag = true;`: 词法分析器还跟踪第三个`previous_end_`指针，因此在构造`Token`时它可以获取词素之间的数据（通常为空白）。这个例子说明了在短FIDL片段const bool flag = true;上调用Lex（）期间指针如何变化：

Initial state after lexing the `const` keyword:  字典化const关键字后的初始状态：

```
 const bool flag = true;
      ^current_
      ^token_start_
      ^previous_end_
```
 

Whitespaces are skipped until the next lexeme:  空格被跳过直到下一个词素：

```
const bool flag = true;
      ^current_
      ^token_start_
     ^previous_end_
```
 

The `current_` pointer is updated until the end of the lexeme:  `current_`指针被更新，直到词尾结束：

```
const bool flag = true;
          ^current_
      ^token_start_
     ^previous_end_
```
 

At this point, the next `Token` that gets returned is ready to be constructed. A `Token` is created with its `previous_end_` argument set to the data between `previous_end_` and `token_start_`. The`location_` is set to the data between `token_start_` and `current_`. The kind is set to`Identifier`. Before returning, the pointers are reset and end up in a state similar to the initialstate. This process can then be repeated for the next token: 此时，准备构造下一个返回的“令牌”。创建一个“令牌”，其“ previous_end_”参数设置为“ previous_end_”和“ token_start_”之间的数据。 “ location_”被设置为“ token_start_”和“ current_”之间的数据。种类设置为“标识符”。在返回之前，指针将被重置并以类似于初始状态的状态结束。然后可以为下一个令牌重复此过程：

```
 const bool flag = true;
           ^current_
           ^token_start_
           ^previous_end_
```
 

Internally the two pointers are manipulated with these main methods:  在内部，这两个指针是通过以下主要方法进行操作的：

 
* `Skip()`. Skips over any unnecessary characters (e.g. whitespace) by moving both the `current_` and the `token_start_` pointers forward. *`Skip（）`。通过向前移动“ current_”和“ token_start_”指针，跳过任何不必要的字符（例如，空格）。
* `Consume()`. Returns the current character and advances `current_`.  *`Consume（）`。返回当前字符并前进“ current_”。
* `Reset()`. Returns the data between `token_start_` and `current_`. Then, sets `token_start_`  to the value of `current_`. *`Reset（）`。返回介于“ token_start_”和“ current_”之间的数据。然后，将“ token_start_”设置为“ current_”的值。

 
### Parsing {#parsing}  解析{parsing} 

The `Parser`'s goal is to convert a `Token` stream into a parse tree (the `raw::` AST) with the `Parse()` method. The `Token` stream is generated by calling `Lex` repeatedly on a FIDL file. Thisparser is implemented with [recursivedescent](https://en.wikipedia.org/wiki/Recursive_descent_parser). Each node of the raw AST has acorresponding `ParseFoo()` method that consumes `Token`s from the `Lexer` and returns a`unique_ptr` to an instance of that node. In case there is a failure, a `nullptr` is returned. “解析器”的目标是使用“解析”方法将“令牌”流转换为解析树（“ RAW ::`AST”）。通过在FIDL文件上反复调用`Lex`来生成`Token`流。该解析器使用[recursivedescent]（https://en.wikipedia.org/wiki/Recursive_descent_parser）实现。原始AST的每个节点都有一个对应的“ ParseFoo（）”方法，该方法从“ Lexer”中消耗“令牌”，然后将“ unique_ptr”返回到该节点的实例。万一发生故障，将返回“ nullptr”。

Note: A node of the raw AST is a [start and end token pair](#sourceelement) with pointers to any children. The start and end tokens of each child are contained within the start and end tokensof its parent. The root node, which is a `raw::File`, has a start token equal to thefirst token of the file and an end token equal to the last token of the file. 注意：原始AST的节点是[开始和结束令牌对]（sourceelement），具有指向任何子代的指针。每个子代的开始和结束标记都包含在其父代的开始和结束标记中。根节点是“ raw :: File”，其起始标记等于文件的第一个标记，结束标记等于文件的最后一个标记。

The `Parser` keeps track of the:  Parser跟踪以下内容：

 
* Current nodes that are being built using a stack of [`SourceElements`](#sourceelement), which are stored in `active_ast_scopes_`. *当前正在使用[[SourceElements]]（sourceelement）堆栈构建的节点，这些节点存储在active_ast_scopes_中。
* Current and previous `Token`s that are being processed. `last_token_` and `previous_token_`, respectively. *当前和先前正在处理的令牌。 `last_token_`和`previous_token_`。
* Its own state machine inside of the `Parser::Lex` method. The current token (`last_token_`) is always the next token that is about to be consumed, which effectively gives the parser a onetoken lookahead (i.e. LL(1)). *在Parser :: Lex`方法内部的自己的状态机。当前令牌（`last_token_`）始终是下一个将要使用的令牌，这有效地使解析器提前一个令牌（即LL（1））。

The `Parser` determines what kind of node the current `Token` belongs to based on the `Token::Kind` of `last_token_`, using the `Peek()` method. Then, the `Parser` updates its state and constructs thenodes through the use of the `ASTScope` class as well as the `ConsumeToken` and `MaybeConsumeToken`helper methods. “解析器”使用“ Peek（）”方法，根据“ last_token_”的“ Token :: Kind”确定当前“令牌”所属的节点类型。然后，解析器通过使用ASTScope类以及ConsumeToken和MaybeConsumeToken帮助器方法来更新其状态并构造节点。

This example shows a simple non-recursive case line by line. The parser method looks like this:  此示例逐行显示了一个简单的非递归案例。解析器方法如下所示：

```c++
std::unique_ptr<raw::StringLiteral> Parser::ParseStringLiteral() {
    ASTScope scope(this);
    ConsumeToken(OfKind(Token::Kind::kStringLiteral));
    if (!Ok())
        return Fail();

    return std::make_unique<raw::StringLiteral>(scope.GetSourceElement());
}
```
 

It consumes a single token and returns a leaf node, `raw::StringLiteral`:  它消耗一个令牌并返回一个叶子节点`raw :: StringLiteral`：

```c++
class StringLiteral : public SourceElement {
public:
    explicit StringLiteral(SourceElement const& element) : SourceElement(element) {}

    virtual ~StringLiteral() {}
}
```
 

The method starts by creating a new `ASTScope` which initializes the `SourceElement` that will later be used to create the returned node by pushing it onto `active_ast_scopes_`. The start ofthe `SourceElement` gets set to the first token that is consumed and the end gets set in the callto `GetSourceElement()` before returning. 该方法首先创建一个新的ASTScope，该实例将初始化SourceElement，然后将其推入active_ast_scopes_来创建返回的节点。 SourceElement的开头被设置为第一个消耗的令牌，而结尾在返回之前在callGetGetElementElement（）中被设置。

The new `SourceElement` for the `StringLiteral` gets initialized inside the `ASTScope` constructor:  用于StringLiteral的新SourceElement在ASTScope构造函数中初始化：

```c++
parser_->active_ast_scopes_.push_back(raw::SourceElement(Token(), Token()));
```
 

Then, `ConsumeToken` is called to process the next token. This method takes a predicate constructed with `OfKind()` and calls that predicate on `last_token_`'s kind or subkind. `OfKind()` returns afunction that checks that its input matches the given kind or subkind. If the predicate fails (inthis case, if the current token is not a string literal), the error gets stored in the class andthe method returns. The `Ok()` call catches the error and stops the compiler with a parsing error.If the predicate succeeds, the start token of any `SourceElement`s in the stack that areuninitialized are set to the current token: 然后，调用“ ConsumeToken”来处理下一个令牌。该方法采用由OfKind（）构造的谓词，并根据last_token_的种类或子种类调用该谓词。 OfKind（）返回一个函数，该函数检查其输入是否与给定的种类或子种类匹配。如果谓词失败（在这种情况下，如果当前令牌不是字符串文字），则将错误存储在类中，然后该方法返回。 Ok（）调用捕获错误并以解析错误停止编译器。如果谓词成功，则堆栈中任何未初始化的SourceElement的启动令牌将设置为当前令牌：

```c++
for (auto& scope : active_ast_scopes_) {
    if (scope.start_.kind() == Token::Kind::kNotAToken) {
        scope.start_ = token;
    }
}
```
 

In this example, the start token is set to the top element of the stack since it was initialized at the start of the method. The `Parser` then advances to the next token by setting `previous_token_ =last_token_` and `last_token_ = Lex()`. 在此示例中，由于开始令牌是在方法开始时初始化的，因此将其设置为堆栈的顶部元素。然后，通过设置`previous_token_ = last_token_`和`last_token_ = Lex（）`，“解析器”前进到下一个令牌。

Finally, the resulting `StringLiteral` node is returned using `scope.GetSourceElement()`. This sets the end token of the `SourceElement` at the top of the stack to the `previous_token_`, and thenreturns the `SourceElement`. The final node has the same start and end token because`StringLiteral`s are only ever a single token long, but other methods may consume many tokensbefore calling `GetSourceElement()`. When the method returns, the destructor of `ASTScope` pops thetop element off of `active_ast_scopes_`. 最后，使用scope.GetSourceElement（）返回结果的StringLiteral节点。这会将堆栈顶部的“ SourceElement”的结束标记设置为“ previous_token_”，然后返回“ SourceElement”。最终节点具有相同的开始和结束令牌，因为StringLiteral的长度仅为单个令牌，但是其他方法在调用GetSourceElement（）之前可能会消耗许多令牌。当方法返回时，`ASTScope`的析构函数将toptop元素弹出到`active_ast_scopes_`中。

 
### Compilation  汇编 

At this point, the compiler has succesfully constructed a `raw::File` for each input file and proceeds to compile these raw ASTs into flat ASTs in three steps: 至此，编译器已经为每个输入文件成功构建了一个“ raw :: File”，并通过三个步骤将这些原始AST编译为平面AST：

 
1. **Consumption**: where the raw ASTs (whose representation tries to match the FIDL grammar) are grouped by FIDL library and de-sugared into flat ASTs (whose representation tries to match theFIDL language semantics). This step converts one `raw::File` per file into one `flat::Library`per library. 1. **消费**：原始的AST（其表示尝试匹配FIDL语法）通过FIDL库进行分组，然后分解为平面AST（其表示尝试匹配FIDL语言语义）。此步骤将每个文件一个`raw :: File`转换为每个库一个`flat :: Library`。
2. **Topological Sorting**: to determine the order in which to resolve the flat AST nodes (see next step). 2. **拓扑排序**：确定解析平面AST节点的顺序（请参阅下一步）。
3. **Resolution**: which performs name resolution, type resolution, and type shape and size calculations. The resolution process is done node by node, and the resulting information isstored into the `flat::` node itself. 3. **分辨率**：执行名称解析，类型解析以及类型形状和大小的计算。解析过程逐节点完成，结果信息存储在“ flat ::”节点本身中。

Note: Within the code, the term "compilation" may refer to these three steps as a whole (for example, all three steps are performed within the `Library::Compile` method), or it could referspecifically to the "resolution" step (for example, the logic for performing resolution iscontained in the `Library::CompileDecl` method ). In general this document tries to use"resolution" when referring to the third step to disambiguate between the two possible meanings. 注意：在代码中，术语“编译”可以整体上指这三个步骤（例如，所有三个步骤都在“ Library :: Compile”方法中执行），或者可以专门指代“解析”步骤（例如，执行解析的逻辑包含在`Library :: CompileDecl`方法中）。通常，当提到第三步骤时，该文件试图使用“分辨率”来消除两种可能含义之间的歧义。

 
#### Consumption  消费 

After each file is parsed into a `raw::File` and an empty AST (`flat::Library`) has been initialized for each library, the AST needs to be updated with all of data from the `raw::File`sthat correspond to it. This is done recursively with the `ConsumeFoo()` methods. Each`ConsumeFoo()` method generally takes the corresponding raw AST node as input, updates the`Library` class, and then return a `bool` to indicate success or failure. These methods areresponsible for: 在将每个文件解析为“ raw :: File”并且为每个库初始化了一个空的AST（“ flat :: Library”）之后，需要使用raw :: File中的所有数据来更新AST。与之相对应的。这可以通过`ConsumeFoo（）`方法来递归地完成。每个“ ConsumeFoo（）”方法通常都将相应的原始AST节点作为输入，更新“ Library”类，然后返回“ bool”以指示成功或失败。这些方法负责：

 
* Validating the placement of attributes; for example checking that the `Transport` attribute is only specified for protocols. *验证属性的位置；例如，检查仅为协议指定了“ Transport”属性。
* Checking for any undefined library dependencies (e.g. using `textures.Foo` will error if the `textures` library was not imported) *检查任何未定义的库依赖项（例如，如果未导入`textures`库，则使用`textures.Foo`将出错）
* Converting the raw AST nodes into their flat AST node equivalents, and storing them in the `Library`'s `foo_declarations_` attribute. Initially the values of the flat AST nodes are unsetbut they are calculated later during compilation. *将原始AST节点转换为等效的AST节点，并将其存储在`Library'的`foo_declarations_`属性中。最初，平面AST节点的值未设置，但稍后会在编译过程中进行计算。
* Registering each [declaration](#decl) by adding them to the `declarations_` vector. Const declarations and enum/bit fields (which declare a value) are also added to the `constants_`vector, whereas all other declarations (which declare a type) get their corresponding [typetemplate](#typetemplate) added to the library's [typespace](#typespace). *通过将每个[declaration]（decl）添加到`declarations_`向量中来进行注册。 const声明和enum / bit字段（声明一个值）也被添加到“ constants_”向量中，而所有其他声明（声明一个类型）都将其对应的[typetemplate]（typetemplate）添加到库的[typespace]（类型空间）。

 
#### Topological Sorting  拓扑排序 

Once all of the declarations for a given `Library` have been added to the `declarations_` vector, the compiler can proceed to resolve each individual declaration. However, it must do this in thecorrect order (so that any dependencies of a declaration are resolved before it); this isaccomplished by first sorting the declarations into a separate `declarations_order_` vector, andthen iterating through it to compile each declaration. The sorting is done in the`SortDeclarations()` method, and makes use of `DeclDependencies()` to determine the dependenciesfor a given declaration. 将给定“库”的所有声明添加到“ declarations_”向量中后，编译器可以继续解析每个单独的声明。但是，它必须以正确的顺序执行此操作（这样才能在声明之前解决声明的任何依赖项）；通过首先将声明分类到单独的`declarations_order_`向量中，然后对其进行迭代以编译每个声明来完成此操作。排序是通过`SortDeclarations（）`方法完成的，并利用`DeclDependencies（）`来确定给定声明的依赖关系。

 
#### Resolution  解析度 

Given the sorted declarations, the compilation happens through the `CompileFoo` methods, generally correponding to the AST nodes (e.g. `CompileStruct`, `CompileConst`), with `CompileDecl` as theentrypoint. The main purpose of `CompileDecl` is for: 给定排序后的声明，编译将通过CompileFoo方法进行，通常对应于AST节点（例如CompileStruct，CompileConst），并以CompileDecl作为入口点。 CompileDecl的主要目的是：

 
* [`TypeDecl`s](#decl) to determine their [`TypeShape`](#typeshape)  * [`TypeDecl`s]（decl）确定其[`TypeShape`]（typeshape）
* [`Const`s](#decl) to resolve their value, and  * [`Const`s]（decl）解析其值，并且
* `TypeConstructor`s to set their [`Type`](#type).  *`TypeConstructor`设置其[`Type`]（type）。

Once this step is complete, the `flat::Library` contains all the necessary information for any code generation. The FIDL compiler can directly generate C bindings, or can generate a JSON IR that canbe consumed by a separate backend 完成此步骤后，`flat :: Library`将包含所有代码生成所需的所有必要信息。 FIDL编译器可以直接生成C绑定，也可以生成可以由单独的后端使用的JSON IR

 
#### Additional Checks  额外支票 

Before marking compilation as successful, the FIDL compiler also does a few additional checks: for example, it will check that any constraints on attributes are satisifed, and that all declaredlibrary dependencies were actually used. 在将编译标记为成功之前，FIDL编译器还进行了一些其他检查：例如，它将检查是否满足对属性的所有约束，并且是否实际使用了所有已声明的库依赖关系。

 
### Backend generation  后端生成 

The FIDL compiler emits a [JSON intermediate representation (IR)][schema]. The JSON IR is consumed by a separate program, named the **back-end**, that generates the language bindings fromthe JSON IR. FIDL编译器发出[JSON中间表示（IR）] [模式]。 JSON IR由一个名为**后端**的单独程序使用，该程序从JSON IR生成语言绑定。

The officially supported FIDL language back-ends are:  官方支持的FIDL语言后端是：

 
* C++, Rust, and Go: [fidlgen][fidlgen]  * C ++，Rust和Go：[fidlgen] [fidlgen]
* Dart: [fidlgen_dart][fidlgen-dart]  * Dart：[fidlgen_dart] [fidlgen-dart]

 
### C Bindings  C绑定 

For historical reasons, C bindings are directly generated from the FIDL compiler - the C bindings do not support all features and types that are used with the C bindings need to be annotated withthe [`Layout = "Simple"`][layout-attr] attribute. 由于历史原因，C绑定是直接从FIDL编译器生成的-C绑定不支持与C绑定一起使用的所有功能和类型，需要使用[`Layout =“ Simple”`] [layout-attr]进行注释属性。

 
### C Family Runtime  C系列运行时 

`fidlc` is also responsible for generating "coding tables", which are instances of `fidl_type_t` used to represent the FIDL messages at runtime and are used by all of the bindings for the C family oflanguages (C, LLCPP, HLCPP). To do this, the flat AST is converted to an intermediaterepresentation called the "coded" AST with the `CodedTypesGenerator`, which iterates through the`flat::Decl`s in a given `flat::Library` and converts each `raw::Decl` node to the corresponding`coded::Type` node (e.g. `flat::Struct` becomes a `coded::StructType`). “ fidlc”还负责生成“编码表”，它们是“ fidl_type_t”的实例，用于在运行时表示FIDL消息，并且由C语言族（C，LLCPP，HLCPP）的所有绑定使用。为此，将AST转换为带有CodedTypesGenerator的中间表示形式，称为“编码” AST，它在给定的flat :: Library中遍历flat :: Decl并转换每个raw： ：Decl节点到相应的code :: Type节点（例如，flat :: Struct变成code :: StructType）。

The coding tables are then generated by the `TablesGenerator`, which will generate C code for each `coded::Type` that constructs the equivalent `fidl_type_t` type. For example, for a`coded::StructType` called `MyStruct`, the `TablesGenerator` would write out C code that constructsan equivalent `fidl::FidlCodedStruct`, something like: 然后，由TablesGenerator生成编码表，TablesGenerator将为构造等效的fidl_type_t类型的每个`code :: Type`生成C代码。例如，对于一个名为MyStruct的code :: StructType，TablesGenerator会写出构成等效的fidl :: FidlCodedStruct的C代码，例如：

```C
const fidl_type_t MyStruct = fidl_type_t(::fidl::FidlCodedStruct(
    my_struct_fields, 1u, 32u, "mylibrary/MyStruct"));
```
 

An example of generated coding tables can be found in [extra_messages.cc][extra_messages]. The [README][coding-readme] gives additional context. The `fidl_type_t` definitions (such as for`FidlCodedStruct`) can be found in [internal.h][internal]. 生成的编码表的示例可以在[extra_messages.cc] [extra_messages]中找到。 [README] [coding-readme]提供了其他上下文。可以在[internal.h] [internal]中找到“ fidl_type_t”定义（例如，针对“ FidlCodedStruct”的定义）。

 
### Glossary  词汇表 

 
#### Decl {#decl}  Decl {decl} 

The `Decl` is the base of all flat AST nodes, just like `SourceElement` is the base of all parser tree nodes, and corresponds to all possible declarations that a user can make in a FIDL file. Thereare two types of `Decl`s: Decl是所有平面AST节点的基础，就像SourceElement是所有解析器树节点的基础一样，并且对应于用户可以在FIDL文件中进行的所有可能的声明。 Decl有两种类型：

 
* `Const`s, which declare a value, and have a `value` attribute that gets resolved during compilation, and *`Const`s，它声明一个值，并具有一个“ value`”属性，该属性在编译期间会被解析，并且
* `TypeDecl`s, which declare a message type or interface and have a `typeshape` attribute that gets set during compilation. *`TypeDecl`s，它声明消息类型或接口，并具有在编译过程中设置的`typeshape'属性。

`TypeDecl`s representing an aggregate type (e.g. structs, tables, unions, and xunions) also have a static `Shape()` method which contains the logic for determining the `Typeshape`of that given type. 代表聚合类型（例如结构，表，联合和轴心）的TypeDecl也具有静态的Shape（）方法，该方法包含确定给定类型的Typeshape的逻辑。

 
#### FieldShape {#fieldshape}  FieldShape {fieldshape} 

A `FieldShape` describes the offset and padding information for members of an aggregate type like a struct or union. Generally these fields will require both a `Typeshape` as well as a `FieldShape` “ FieldShape”描述了诸如struct或union的聚合类型成员的偏移量和填充信息。通常，这些字段将需要同时使用Typeshape和FieldShape

 
#### Name {#name}  名称{name} 

A `Name` represents a scope variable name, and consists of the library the name belongs to (or `nullptr` for global names), and the variable name itself as a string (for anonymous names) or a`SourceLocation`. `Name`s can alos optionally include a `member_name_` field when referring to thefield of a declared variable (for example `MyEnum.MyField`). Name表示作用域变量名，由名称所属的库组成（对于全局名，则为nullptr），而变量名本身则为字符串（对于匿名名）或SourceLocation。当引用已声明变量的字段（例如，MyEnum.MyField）时，Name可以选择包括一个member_name_字段。

 
#### SourceElement {#sourceelement}  SourceElement {sourceelement} 

A `SourceElement` represents a block of code inside a fidl file and is parameterized by a `start_` and `end_` `Token`. All parser tree ("raw" AST) nodes inherit from this class. SourceElement代表fidl文件中的代码块，并由start_和end_Token进行参数化。所有解析器树（“原始” AST）节点都从此类继承。

 
#### SourceFile {#sourcefile}  SourceFile {sourcefile} 

Wrapper around a file which is responsible for owning the data in that file. Also see [Virtual SourceFile](#virtualsourcefile) 包装文件，负责拥有该文件中的数据。另请参见[Virtual SourceFile]（virtualsourcefile）

 
#### SourceLocation {#sourcelocation}  SourceLocation {sourcelocation} 

Wrapper around a `StringView` and the `SourceFile` it comes from. It provides methods to get the surrounding line of the `StringView` as well as its location in the form of a`"[filename]:[line]:[col]"` string 包装一个`StringView`和它来自的`SourceFile`。它提供方法来获取`StringView`的周围的线及其位置，形式为`“ [filename]：[line]：[col]”`字符串

 
#### SourceManager {#sourcemanager}  SourceManager {sourcemanager} 

Wrapper around a set of `SourceFile`s that all relate to a single `Library`.  所有与单个“库”相关的“ SourceFile”集的包装器。

 
#### Token {#token}  令牌{token} 

A token is essentially a lexeme (in the form of a [`SourceLocation`](#sourcelocation) stored as the `location_` attribute), enhanced with two other pieces information that are useful to the parserduring the later stages of compilation: 令牌本质上是一个词素（以[`LocationLocation`]（sourcelocation的形式存储为`location_`属性的形式），并通过另外两段信息进行了增强，这对于在后期编译阶段进行解析很有用：

 
* `previous_end_`. A `SourceLocation` which starts at the end of the previous token and ends at the start of this token. It contains data that is uninteresting to the parser such as whitespace. *`previous_end_`。一个“ SourceLocation”，从上一个令牌的末尾开始，到此令牌的末尾结束。它包含解析器不感兴趣的数据，例如空格。
*  A kind and subkind which together classifies the lexeme. The possible kinds are:  *将词素分类的种类和子种类。可能的种类有：
   * The special characters such as `Kind::LeftParen`, `Kind::Dot`, `Kind::Comma`, etc...  *特殊字符，例如`Kind :: LeftParen`，`Kind :: Dot`，`Kind :: Comma等，等等...
   * String and numeric constants  *字符串和数字常量
   * Identifiers. Tokens that are keywords (e.g. `const`, `struct`) are considered identifiers, but also have a subkind defined to identify which keyword it is (e.g. `Subkind::Const`,`Subkind::Struct`). All other tokens have a subkind of `None`. * 身份标识。作为关键字的令牌（例如const，struct）被视为标识符，但也定义了子种类以标识它是哪个关键字（例如Subkind :: Const，Subkind :: Struct）。所有其他令牌的子类型均为“无”。
   * Uninitialized tokens have a kind of `kNotAToken`.  *未初始化的令牌有一种`kNotAToken`。

 
#### Type {#type}  输入{type} 

A struct representing an instance of a type. For example, the `vector<int32>:10?` type corresponds to an instance of the `VectorType` `TypeDecl` with `max_size_ = 10` and `maybe_arg_type` set to the`Type` corresponding to `int32`. Built-in types all have a static `Shape()` method which willreturn the `Typeshape` given the parameters for an instance of that type. User defined types (e.g.structs or unions) will all have a type of `IdentifierType` - the corresponding[`TypeDecl`](#typedecl), like `Struct` provides the static `Shape()` method instead. 表示类型实例的结构。例如，“ vector <int32>：10？”类型对应于“ VectorType” TypeDecl的实例，其中“ max_size_ = 10”且“ maybe_arg_type”设置为与“ int32”相对应的“ Type”。内置类型都有一个静态的Shape（）方法，该方法将在给定类型实例的参数的情况下返回Typeshape。用户定义的类型（例如structs或unions）都将具有`IdentifierType`类型-相应的[`TypeDecl`]（typedecl），就像`Struct`提供了静态`Shape（）`方法一样。

 
#### TypeDecl {#typedecl}  TypeDecl {typedecl} 

See [`Decl`](#decl)  参见[`Decl`]（decl）

 
#### TypeShape {#typeshape}  TypeShape {typeshape} 

Information about how objects of a type should be laid out in memory, including their size, alignment, depth, etc. 有关应如何在内存中布置某种类型的对象的信息，包括它们的大小，对齐方式，深度等。

 
#### Typespace {#typespace}  类型空间{typespace} 

The typespace is a map from [`Type`](#type) names to a `TypeTemplate` for that `Type`. During compilation, the typespace is initialized to include all of the built-in types (e.g. `"vector"`maps to `VectorTypeTemplate`), whereas user-defined types get added during the compilation process.This also ensures that a single type template instance exists per type and avoids namecollisions/shadowing of types (e.g. FIDL-310). 类型空间是从[`Type`]（type）名称到该“ Type”的`TypeTemplate`的映射。在编译期间，类型空间被初始化为包括所有内置类型（例如，“ vector”映射到“ VectorTypeTemplate”），而用户定义的类型在编译过程中被添加。这还确保了单个类型模板每个类型都存在一个实例，并避免名称冲突/类型混淆（例如FIDL-310）。

 
#### TypeTemplate {#typetemplate}  TypeTemplate {typetemplate} 

Instances of TypeTemplates provide a `Create()` method to create a new instance of a specific `Type` - therefore there is a TypeTemplate subclass for each built-in FIDL type (e.g.`ArrayTypeTemplate`, `PrimitiveTypeTemplate`, etc.) as well as a single class for all user definedtypes (`TypeDeclTypeTemplate`), and one for type aliases (`TypeAliasTypeTemplate`). `Create()`takes as parameters the possible type parameters: argument type, nullability, and size. TypeTemplate的实例提供了一种Create（）方法来创建特定类型的新实例-因此，每个内置FIDL类型（例如ArrayTypeTemplate，PrimitiveTypeTemplate等）都有一个TypeTemplate子类，如下所示：以及一个用于所有用户定义类型的单一类（TypeDeclTypeTemplate），以及一个用于类型别名的类型（TypeAliasTypeTemplate）。 Create（）将可能的类型参数作为参数：参数类型，可为空性和大小。

For example, to create an object representing the type `vector<int32>:10?` the compiler would call the `Create()` method of the `VectorTypeTemplate` with an argument type of `int32`, max size of`10`, and a nullability of `types::Nullability::kNullable`. This call returns an instance of a`VectorType` with those parameters. Note that not all 3 of these parameters apply to all of thetypes (e.g. `PrimitiveType`s, like `int32` have none of the 3). The `Create()` method of the typetemplate for each type automatically checks that only the relevant parameters are passed. 例如，要创建一个表示类型为vector <int32>：10？的对象，编译器将调用参数类型为int32，最大大小为10的VectorTypeTemplate的Create（）方法。 ，以及`types :: Nullability :: kNullable`的可空性。该调用返回带有这些参数的VectorType的实例。请注意，并非所有这三个参数都适用于所有类型（例如，`PrimitiveType`s，如`int32`都不具有这三个类型）。每个类型的typetemplate的Create（）方法都会自动检查是否仅传递了相关参数。

The concrete type for user defined types is the `IdentifierType`, which gets generated by the `TypeDeclTypeTemplate`. 用户定义类型的具体类型是IdentifierType，由TypeDeclTypeTemplate生成。

 
#### Virtual SourceFile {#virtualsourcefile}  虚拟源文件{virtualsourcefile} 

A subclass of `SourceFile` that has a fake "filename" and is initialized with no backing data. It exposes an `AddLine()` method to add data to the file, and is used as a backing `SourceFile` forcontent that does not appear directly in any of the input `SourceFile`s, like for generatedanonymous [`Name`](#name)s. SourceFile的子类，具有假的“文件名”，并且没有后备数据进行初始化。它公开了一个AddLine（）方法来向文件中添加数据，并被用作SourceFile的后备内容，该内容不会直接出现在任何SourceFile的输入中，例如generateanonymous [`Name]]（名称）。

