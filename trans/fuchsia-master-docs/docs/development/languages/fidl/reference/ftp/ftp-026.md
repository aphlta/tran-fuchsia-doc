> This [FTP](README.md) is rejected  >该[FTP]（README.md）被拒绝

 
# Rejection Rationale  拒绝理由 

Given the amount of feedback and comments on this FTP, we've decided to withdraw (i.e. self-reject) the proposal.That said, it still has some great ideas: we'll be taking those ideas andpublishing them as separate FTPs with smaller scope, to enable clearerdiscussion and separate independent features into their own FTPs. 鉴于对该FTP的反馈和意见众多，我们决定撤回（即自我拒绝）该提案。尽管如此，它仍然有一些不错的主意：我们将采纳这些主意并将其作为单独的FTP发布，并以较小的FTP形式发布。范围，以便进行更清晰的讨论并将独立的功能分离到自己的FTP中。

[FTP-032][ftp-032] was spun out of this FTP.  [FTP-032] [ftp-032]是从此FTP中转出的。

 
# [FIDL Tuning Proposal](README.md) 026  [FIDL调整建议]（README.md）026 

Envelopes Everywhere ==================== 到处都有信封====================

Field     | Value ----------|-------------------------------------------------------------Status    | RejectedAuthors   | apang@google.com, ianloic@google.com, pascallouis@google.comSubmitted | 2019-01-19Reviewed  | 2019-02-04 领域值---------- | -------------------------------------------------------- -----------------------状态|拒绝作者| apang @ google.com，ianloic @ google.com，pascallouis @ google.com提交|评论2019-01-19 | 2019-02-04

[TOC]  [目录]

 
## Summary  摘要 

This FTP has two goals:  这个FTP有两个目标：

 
1. Improve the efficiency of the existing [envelope] format, by making envelopes more than twice as compact. 1.通过使信封紧凑两倍以上来提高现有[信封]格式的效率。
2. Use envelopes as the sole means of referencing _all_ out-of-line objects. This increases the consistency of the wire format, and the uniformity ofprotocol design and implementation. 2.使用信封作为引用_all_离线对象的唯一方法。这增加了线路格式的一致性，以及协议设计和实现的一致性。

A side-effect of both (1) and (2) is that optionality (nullability) can be efficiently implemented for all types, not just structs, handles, vectors,strings, tables and (extensible) unions[[1]](#footnote1) （1）和（2）的副作用是可以对所有类型有效地实现可选性（可空性），而不仅仅是结构，句柄，向量，字符串，表和（可扩展）并集[[1]]（footnote1 ）

 
## Motivation  动机 

Envelopes are the foundation for extensible, evolvable data structures (tables and extensible unions).Making envelopes more efficient enables those extensible structures to beused in more contexts where performance and wire size matter. 信封是可扩展，可发展的数据结构（表和可扩展联合）的基础。提高信封的效率可使那些可扩展的结构在性能和电线尺寸至关重要的环境中使用。

FIDL also has several pervasive types that are used for dynamically-sized data: vectors & strings.These types are required to be out-of-line since the size of the FIDL primaryobject is expected to be statically known.If envelopes can be used to represent all out-of-line data, we can simplifyboth the protocol and implementation, reducing implementation cost and roomfor error. FIDL还具有几种用于动态调整大小的数据的泛型类型：向量字符串。由于FIDL主要对象的大小应该是静态已知的，因此这些类型必须是非常规的。如果可以使用信封来表示所有离线数据，我们都可以简化协议和实现，从而降低实现成本和出错空间。

Additionally, FIDL would benefit from a holistic, consistent approach to optionality.This leads to better ergonomics, optionality for more types than the currentmechanisms allow for, and a simplified user mental model.Envelopes fulfill these goals by enabling optionality for all types in auniform manner. 此外，FIDL将从整体，一致的可选方法中受益，这将带来更好的人机工程学，比当前机制所允许的更多类型的可选性以及简化的用户思维模型。信封通过以统一的方式为所有类型启用可选性来实现这些目标。

 
## Design  设计 

Envelopes can refer to data that is either:  信封可以引用以下数据之一：

 
*   _out-of-line_, similar to the existing envelope format, or  * _out-of-line_，类似于现有的信封格式，或者
*   _inline_, where data is stored in the envelope itself. This can be used for "small-sized" types that are fixed-size and lessthan 64 bits. * _inline_，其中数据存储在信封本身中。可以将其用于固定大小且小于64位的“小型”类型。

 
### Out-Of-Line Envelopes  线外信封 

An out-of-line envelope is:  离线信封是：

![Figure: out of line envelope, 64 bit little endian, lower 48 bits size with least significant bit zero, 16 bits handle_count](ftp-026-figure1.png) ！[图：外线包络，64位小字节序，低48位大小，最低有效位零，16位handle_count]（ftp-026-figure1.png）

As a C struct:  作为C结构：

```c
typedef struct {
  uint64_t size:48;  // Low bit will be 0
  uint16_t handle_count;
} fidl_out_of_line_envelope_t;
```
 

The out-of-line envelope has the following changes vs the [existing envelope format][envelope]: 与[现有信封格式] [信封]相比，离线信封有以下更改：

 
*   **Size (num_bytes) is 48 bits instead of 32 bits**, enabling larger payloads. * **大小（num_bytes）是48位而不是32位**，从而实现了更大的有效负载。
    *   The size includes the size of any sub-objects that may be recursively encoded. *大小包括可以递归编码的任何子对象的大小。
        *   For example, the size of a `vector<string>` includes the size of the outer vector's inner string sub-objects. *例如，“ vector <string>”的大小包括外部向量的内部字符串子对象的大小。
        *   This matches the existing behavior for the current envelope implementation's size field. *这与当前信封实现的size字段的现有行为匹配。
    *   A legitimate out-of-line object's size will always be a multiple of  *合法的离线对象的大小将始终是的倍数
        8, due to out-of-line objects being eight-byte aligned. This implies that `size % 8 == 0`, which means that 在图8中，由于行外对象是8字节对齐的。这意味着`size％8 == 0`，这意味着
        *   the lowest three bits of the size field &mdash; and thus the LSB of the size field &mdash; will be zero, thus * size字段mdash的最低三位；因此，大小字段的LSB为-将为零，因此
        *   the envelope's LSB &mdash; since the size field is in the LSB of the envelope &mdash; will always also be zero. *信封的最低有效位（LSB）–因为size字段位于信封mdash的LSB中；也将始终为零。
        *   This is important, as discussed in the [Tag Bit](#tag-bit) below.  *这很重要，如下面的[标签位]（标签位）中所述。
    *   See [Encoding Sizes for Out-of-Line Envelopes](#encoding-sizes-for-out_of_line-envelopes) below forperformance implications of calculating the recursive size. *有关计算递归大小的性能含义，请参见下面的[行外信封的编码大小]（encode-sizes-for-out_of_line_envelopes）。
*   **The `handle_count` is 16 bits, instead of 32 bits.**  * **`handle_count`是16位，而不是32位。**
    *   It's not currently possible to send > 64 handles over a Zircon channel; we feel that 16 bits provides enough headroom for future needs. *当前无法通过Zircon通道发送64个以上的句柄；我们认为16位可以为将来的需求提供足够的空间。
    *   The `handle_count` includes the handle count for all recursive sub-objects. *`handle_count`包括所有递归子对象的句柄计数。
*   **The presence/absence field is dropped.**  * **存在/不存在字段被丢弃。**
    *   Presence is represented by a non-zero value in either the `size` or `handle_count` field. *在“大小”或“处理计数”字段中，存在状态由非零值表示。
    *   Absence is represented by the `size` & `handle_count` fields both being zero. *缺席由大小均为零的handle_count字段表示。
        *   We call this a _zero envelope_.  *我们称其为“零信封”。

Decoders MAY overwrite the envelope with a pointer to the envelope data, assuming they know the static type (schema) of the envelope's contents.See the [Decoder Callback](#decoder-callback) section for recommendations onhow to process an envelope if the content's type is unknown. 如果解码器知道信封内容的静态类型（模式），则可以使用指向信封数据的指针覆盖信封。有关内容类型如何处理信封的建议，请参见[解码器回调]（解码器回调）部分。未知。

 
### Tag Bit  标签位 

An out-of-line envelope explicitly has the size occupying the least significant bits, and the handle count occupying the most significant bits.As discussed in the [Envelope](#out_of_line-envelopes) section, 离线信封的大小明确地占据了最低有效位，而句柄计数则占据了最高有效位。如[信封]（out_of_line-envelopes）部分所述，

 
*   since the lowest bit of the size field will always be zero (due to the size being a multiple of 8), *由于大小字段的最低位将始终为零（由于大小为8的倍数），
*   the lowest bit of the envelope will _also_ always be zero.  *信封的最低位也将始终为零。

We call the lowest bit of the envelope the _tag bit_.  我们将信封的最低位称为_tag bit_。

 
*   If the tag bit is zero, the envelope's data is _out-of-line_.  *如果标记位为零，则信封的数据为_out-of-line_。
*   If the tag bit is one, the envelope's data is _inline_.  *如果标记位为1，则信封的数据为_inline_。

Since the tag bit is one for inline data, an inline envelope also cannot be an actual pointer on architectures that require 64-bit alignment, sincepointers will be a multiple of 8 and also require the lowest three bits to bezero.This is useful for a decoder to be able to distinguish inline envelopes froman actual pointer, since decoders typically overwrite out-of-line envelopes&mdash; but not inline envelopes &mdash; with a pointer to the envelope'scontent. 由于标记位是用于内联数据的一个位，因此内联包络也不能成为要求64位对齐的体系结构上的实际指针，因为指针将是8的倍数并且还要求最低的三个位为零。解码器能够区分行内包络和实际指针，因为解码器通常会覆盖行外包络。但不是内嵌信封-带有指向信封内容的指针。

 
### Inline Envelopes  嵌入式信封 

Inline envelopes are encoded as:  嵌入式信封的编码为：

![Figure: in line envelope, 64 bit little endian, least significant bit is the value 1 indicating tag, 31 bits reserved, then 8, 16, or 32bits of inline data](ftp-026-figure2.png) ！[图：在行信封中，64位小字节序，最低有效位是值1，指示标记，保留31位，然后是8、16或32位内联数据]（ftp-026-figure2.png）

As a C struct:  作为C结构：

```c
typedef struct {
  uint8_t tag:1;  // == 1
  uint32_t reserved:31;
  union {
    _Bool bool;
    uint32_t uint32;
    int32_t int32;
    uint16_t uint16;
    int16_t int16;
    uint8_t uint8;
    int8_t int8;
    float float32;
    zx_handle_t handle;  // Only when decoded (see Handles for more details)
  };
} fidl_inline_envelope_t;
```
 

 
*   Inline envelopes have their LSB set to 1, which differentiates them from out-of-line envelopes and actual pointers. *嵌入式信封的LSB设置为1，这使它们与离线信封和实际指针有所区别。
*   The upper 32 bits of the envelope are used to represent the inline value, which can be an `int8`, `uint8`, `int16`, `uint16`, `int32`, `uint32`,`float32`, `bool`, or a handle. *信封的高32位用于表示内联值，可以是int8，uint8，int16，uint16，int32，uint32，float32，bool或句柄。
    *   The lowest bits of the upper 32 bits are used to represent the value if the value is less than 32 bits wide, which is standardlittle-endian representation. *如果值的宽度小于32位，则高32位的最低位用于表示该值，这是标准的小尾数表示。
*   Encoders MUST encode reserved bits as zero unless a future FTP specifies how those bits are to be interpreted. *除非将来的FTP指定如何解释这些位，否则编码器必须将保留位编码为零。
*   Decoders and validators MUST ignore reserved bits unless a future FTP specifies how those bits are to be interpreted. *除非以后的FTP指定如何解释这些位，否则解码器和验证器必须忽略保留位。
*   Decoders SHOULD leave inline envelopes as-is during decoding.  *解码器应在解码期间保持原样的内联信封。
    *   Since inline data has the data inline instead of needing to be referenced out-of-line, decoders do not need to replace them with apointer when decoding in-place (unlike out-of-line envelopes). *由于内联数据具有内联数据，而不需要在行外引用，因此解码器在就地解码时（与行外信封不同）不需要用指针替换它们。

 
### Should Encoders Encode as Out-of-Line or Inline?  编码器应该编码为离线还是串联？ 

An encoder MUST:  编码器必须：

 
*   encode data inline iff the type is a `bool`, (`u`)`int8`, (`u`)`int16`, (`u`)`int32`, `float32` or handle.(Informally: if the type is fixed-size and <= 32 bits.) *如果类型是`bool`，（`u`）`int8`，（`u`）`int16`，（`u`）`int32`，`float32`或句柄，则对数据进行内联编码（非正式地：如果类型为固定大小且<= 32位。）
*   encode data out-of-line for all other types. (Informally: if the type is >= 64 bits or variable-sized.) *对所有其他类型的数据进行离线编码。 （非正式地：如果类型> = 64位或可变大小。）

 
### Handles  提手 

There are three contexts for handle declaration:  句柄声明有三种上下文：

 
1. a non-optional handle in a non-extensible container, e.g. `struct S { handle h; };` 1.不可扩展的容器中的非可选手柄`struct S {句柄h; };`
2. an optional handle in a non-extensible container, e.g. `struct S { handle? h; };` 2.不可扩展容器中的可选手柄，例如`struct S {句柄？ H; };`
3. a handle in an extensible container, e.g. `table T { handle h; }`  3.可伸长容器中的提手，例如`T T {句柄h; }`

For (1), a non-optional handle in a non-extensible container, we propose keeping the [existing wire format][wformat-handles], which is a `uint32`.There is no need for a non-optional handle in a non-extensible container tobe an envelope, since envelopes are designed to carry optional ordynamically-sized data. 对于（1），它是不可扩展容器中的一个非可选句柄，我们建议保留[existing wire format] [wformat-h​​andles]，它是一个'uint32`。在此，不需要一个非可选句柄一个不可扩展的容器，将其作为信封，因为信封被设计为承载可选的或动态大小的数据。

For (3), a handle in an extensible container: since envelopes are the foundation for extensible containers, an envelope must be used to encode thehandle.To encode a handle, an encoder MUST encode it as an out-of-line envelope,with `size` set to 0, and `handle_count` set to 1: 对于（3），可扩展容器中的句柄：由于信封是可扩展容器的基础，因此必须使用信封对句柄进行编码。要对句柄进行编码，编码器必须将其编码为离线信封，并带有将size设置为0，handle_count设置为1：

![Figure: little-endian 64 bit data field with bottom 48 bits of size set to zero and next 16 bits indicating handle_count set to 1](ftp-026-figure3.png) ！[图：little-endian 64位数据字段，底部48位的大小设置为零，接下来的16位指示handle_count设置为1]（ftp-026-figure3.png）

This encoding instructs a decoder to look up the handle value in the out-of-line handle table.If a decoder wishes to decode in-place, the decoder SHOULD: 该编码指示解码器在离线句柄表中查找句柄值。如果解码器希望就地解码，则解码器应：

 
*   look up the handle in the out-of-line handle table, to determine the actual handle value. *在离线句柄表中查找句柄，以确定实际的句柄值。
*   set the tag bit to 1, which changes the envelope from out-of-line to inline.  *将标记位设置为1，这会将包络从线外更改为线内。
*   set the handle field of the fidl_inline_envelope_t struct to the actual handle value. *将fidl_inline_envelope_t结构的句柄字段设置为实际的句柄值。

![Figure: little-endian 64 bit data field with least significant bit tag set to 1, next 31 bits reserved, next 32 bits handle_value](ftp-026-figure4.png) ！[图：little-endian 64位数据字段，最低有效位标签设置为1，保留的下一个31位，接下来的32位handle_value]（ftp-026-figure4.png）

See the [Examples](#examples) section for an example encoded/decoded handle.  有关示例编码/解码句柄，请参见[Examples]（示例）部分。

We choose this dual encoded/decoded form since it is compatible with both the out-of-line and inline envelope encodings.While this does result in specialized code for handles in envelopes, webelieve that having more uniform, i.e. fewer, data encodings is a bettertrade-off than simpler code that requires more encodings. 我们选择这种双重编码/解码形式，因为它既与行外信封编码也与行内信封编码兼容。尽管这确实导致了信封中句柄的专用代码，但我们相信具有更统一（即更少）的数据编码是一种比需要更多编码的简单代码更好地权衡。

For (2), an optional handle in a non-extensible container: we also propose using the same envelope representation as context (3) for the wire format,i.e. the dual out-of-line-encoded/inline-decoded form.Unfortunately, this representation of an optional handle is less compact thanthe [existing optional handle wire format][wformat-handles], which is a`uint32`.However, we still advocate using the envelope-based representation, since 对于（2），这是不可扩展容器中的可选句柄：对于有线格式，我们还建议使用与上下文（3）相同的信封表示形式，即不幸的是，这种可选句柄的表示形式比[现有的可选句柄线格式] [wformat-h​​andles]（即uint32）紧凑。仍然主张使用基于信封的表示形式，因为

 
*   using an envelope for an optional handle is consistent with using envelopes for any optional type, *使用信封作为可选手柄与将信封用于任何可选类型一致，
*   optional handles are relatively rare in a FIDL message vs other message types[[2]](#footnote2), so the extra 4 bytes of envelope overhead shouldnot significantly impact message size, *与其他消息类型[[2]]（footnote2）相比，可选句柄在FIDL消息中相对较少，因此额外的4个字节的信封开销不会显着影响消息的大小，
*   keeping the existing `uint32` wire format for optional handles would result in three encodings and three separate code paths for handles:non-optional, optional, and handle-in-envelope.Using the envelope representation for optionals eliminates one encodingand one code path, which increases uniformity and decreases specializedcode. *为可选句柄保留现有的uint32有线格式将导致三种编码和三个单独的句柄代码路径：非可选，可选和包络句柄。使用信封表示形式的可选句柄消除了一种编码和一种代码路径，这增加了一致性并减少了专用代码。

The encoding for (2) &mdash; optional handles in a non-extensible container &mdash; is explicitly listed in the [Design Decisions](#design-decisions)section below, since the more compact `uint32` representation for an optionalhandle could be worth considering. （2）的编码-不可扩展容器中的可选句柄-在下面的[设计决策]（设计决策）部分中明确列出，因为可选句柄的更紧凑的`uint32`表示形式值得考虑。

 
### Strings & Vectors  字符串向量 

The current wire format for non-nullable [Strings][wformat-strings] and [Vectors][wformat-vectors] are stored as 16 bytes: 非空[String] [format-strings]和[Vectors] [wformat-vectors]的当前连线格式存储为16个字节：

 
*   a `uint64` for the number of elements (vector) or number of bytes (string),  *一个uint64，表示元素数（向量）或字节数（字符串），
*   a `uint64` for the presence/absence/pointer.  *用于存在/不存在/指针的`uint64`。

We propose using an envelope to represent both strings and vectors, either nullable or non-nullable: 我们建议使用包络来表示可为空或不可为空的字符串和向量：

 
*   **The number of elements (vector) or bytes (string) is moved out-of-line**.  * **元素（向量）或字节（字符串）的数量移出线**。
    *   This enables a vector/string to be represented by an envelope (only), so envelopes become the sole means of referencing _any_ out-of-linedata, for all FIDL types, enabling a consistent representation forall out-of-line data. *这使向量/字符串可以用一个信封表示（仅），因此对于所有FIDL类型，信封成为引用_any_离线数据的唯一方法，从而可以一致地表示所有离线数据。
    *   The vector/string contents are in a separate out-of-line object, and immediately follow the element/byte count. *向量/字符串的内容位于单独的行外对象中，并紧随元素/字节计数之后。
*   Presence/absence is determined by the envelope either being zero or non-zero. *是否存在取决于信封是零还是非零。

For vectors, note that the vector element count is not the same as the envelope's size:  对于矢量，请注意矢量元素计数与信封的大小不同：

 
*   The envelope's size is the vector element count multiplied by the element size. *信封的大小是矢量元素计数乘以元素大小。
*   If the vector contains sub-objects (e.g. `vector<Table>`, `vector<vector<string>>`), the envelope's size includes the size of allrecursive sub-objects. *如果向量包含子对象（例如，“ vector <Table>”，“ vector <vector <string >>”），则信封的大小包括所有递归子对象的大小。

Nullable strings/vectors, and strings/vectors inside extensible containers, are represented the same way as non-nullable strings and vectors: the zeroenvelope is used to indicate an absent string/vector. 可空字符串/向量以及可扩展容器内的字符串/向量的表示方式与不可空字符串和向量相同：零包络用于指示不存在的字符串/向量。

Conversely, if a string/vector is non-nullable, a validator MUST error if it encounters a zero envelope. 相反，如果字符串/向量不可为空，则验证器在遇到零包络时必须出错。

This may be a source-breaking change for code that uses the C bindings, which expect the memory layout for a `fidl_vector_t` and `fidl_string_t`to exactly match the wire format.We can, however, implement a transitional plan before a wire format change(e.g. change the C API to use functions or macros) that enable this to be asoft transition. 这可能是对使用C绑定的代码的破坏源代码的更改，该代码期望`fidl_vector_t`和`fidl_string_t`的内存布局与有线格式完全匹配。但是，我们可以在有线格式之前实施过渡计划更改（例如，更改C API以使用函数或宏），以使其成为一个软过渡。

Note that it's still possible to represent this new string/vector layout as a C struct via [flexible array members][flexible-array-members] (e.g. `struct {uint64 element_count; element_type data[]; };`). 请注意，仍然可以通过[flexible array member] [flexible-array-members]（例如struct {uint64 element_count; element_type data [];};`）将这种新的字符串/矢量布局表示为C结构。

 
### Optional (Nullable) Types  可选（可空）类型 

Currently, structs, strings, vectors, handles, unions, tables and extensible unions can be optional (nullable). 当前，结构，字符串，向量，句柄，并集，表和可扩展并集可以是可选的（可为空）。

**Using envelopes everywhere enables _all_ types to be optional**:  **在各处使用信封可使_all_类型为可选**：

 
*   Present optional data is stored with an envelope, either out-of-line or inline. *当前的可选数据以线外或线内的信封形式存储。
*   Absent optional data is stored as a zero envelope.  *缺少的可选数据存储为零包络。

Note that for small-sized types, inline data can store optional types as compactly as non-optional types, depending on the container's alignmentrequirements. 请注意，对于小型类型，内联数据可以像存储非可选类型一样紧凑地存储可选类型，具体取决于容器的对齐要求。

 
### C/C++ Structs for Encoded/Decoded Forms  编码/解码形式的C / C ++结构 

The encoded form of an envelope can be represented by a union of either an inline or out-of-line envelope.Similarly, a decoded envelope can either be inline, a pointer to the envelopedata, or a callback-determined value (see the [DecoderCallback](#decoder-callback) section for details). 信封的编码形式可以用行内或行外信封的并集来表示。类似地，解码后的信封可以是行内，指向信封数据的指针或由回调确定的值（请参见[ DecoderCallback]（解码器回调）部分了解详情）。

```c
typedef union {
  fidl_inline_envelope_t inline;            // Low bit is 1
  fidl_out_of_line_envelope_t out_of_line;  // Low bit is 0
} fidl_encoded_envelope_t;

typedef union {
  fidl_inline_envelope_t inline;  // Low bit is 1
  void* data;                     // Low bit is 0
  uintptr_t callback_data;  // Value determined by callback (see Decoder Callback)
} fidl_decoded_envelope_t;

static_assert(sizeof(fidl_encoded_envelope_t) == sizeof(void*));
static_assert(sizeof(fidl_decoded_envelope_t) == sizeof(void*));
```
 

 
### Unknown Data  未知数据 

Receivers &mdash; validators & decoders &mdash; may not know the type of an envelope when they're used in an evolvable data structure, such as a tableor extensible union.If a receiver doesn't know the type of an envelope: 接收器-验证者解码器-当它们用于可发展的数据结构（例如表或可扩展联合）中时，它们可能不知道信封的类型。如果接收者不知道信封的类型：

 
*   Inline envelopes can be safely ignored.  *嵌入式信封可以安全地忽略。
    *   Handles MUST be encoded with out-of-line envelopes, not inline envelopes, which makes all inline envelopes safe to ignore. *句柄必须使用行外信封而不是行内信封进行编码，这使得所有行内信封都可以忽略。
*   Out-of-line envelopes can be minimally parsed and skipped.  *可以最少地分析和跳过离线信封。
    *   The envelope's size determines the amount of out-of-line data to skip.  *信封的大小决定了要跳过的离线数据量。
    *   If the envelope's handle count is non-zero, a validator MUST process the specified number of handles. *如果信封的句柄计数不为零，验证器必须处理指定数量的句柄。
        *   The default processing behavior MUST be to close all handles.  *默认处理行为必须是关闭所有句柄。
    *   A decoder MAY overwrite the unknown envelope with a pointer to the envelope's contents, if it wishes to decode in-place. *如果解码器希望就地解码，则可以使用指向其内容的指针覆盖未知的信封。
        *   If a decoder does overwrite the envelope with a pointer, it will lose the size & handle count information in the envelope.If this is problematic, see the [Decoder Callback](#decoder-callback)section for an alternative. *如果解码器确实使用指针覆盖了信封，则它将丢失信封中的大小句柄计数信息。如果这有问题，请参阅[解码器回调]（decoder-callback）部分。

Note that embedding the size in the out-of-line envelope enables rapid linear seeking through a FIDL message if many unknown types need to be skipped. 请注意，如果需要跳过许多未知类型，则将大小嵌入行外信封可通过FIDL消息进行快速线性查找。

 
### Decoder Callback  解码器回调 

As mentioned in the [Unknown Data](#unknown-data) section, an unknown envelope may be overwritten by a decoder: if this happens, the decoder willlose the size and handle count information.As an alternative, a decoder MAY have a callback attached to it that canprocess the envelope and override the default behavior.The callback API can look similar to the following function prototype: 如[未知数据]（未知数据）部分所述，解码器可能会覆盖未知包络：如果发生这种情况，则解码器将丢失大小和处理计数信息。或者，解码器可以附加一个回调它可以处理信封并覆盖默认行为。回调API看起来类似于以下函数原型：

```c
void set_unknown_envelope_callback(
    unknown_envelope_callback_t callback,  // a callback
    void* context                          // client-specific data storage
);

typedef uintptr_t (*unknown_envelope_callback_t)(
    const void* message,  // pointer to the envelope's containing message
    size_t offset,        // offset in the message where the unknown envelope is
    size_t size,          // the envelope's size
    size_t handle_count,  // the envelope's handle count
    const char* bytes,    // pointer to the envelope's data
    void* context         // a context pointer set via set_unknown_envelope_callback()
);
```
 

The callback returns a `uintptr_t`, which the decoder can use to overwrite the unknown envelope with.This enables the decoder to copy the size and handle count from the unknownenvelope, and overwrite the envelope with a pointer to the decoder's owncustom data structure. 回调函数返回一个'uintptr_t'，解码器可以使用它来覆盖未知的信封，这使解码器可以复制未知信封的大小和处理计数，并使用指向解码器自己的自定义数据结构的指针覆盖该信封。

 
### Encoding Sizes for Out-of-Line Envelopes  线外信封的编码大小 

This FTP requires that out-of-line envelopes have the correct (recursive) size for present out-of-line data.This requirement can impose additional burden on an encoder, since if theenvelope's type is expected to be known by the receiver, the size field isunnecessary since the decoder can compute the size[[3]](#footnote3).Thus, the encoder is arguably performing additional work for no apparentbenefit.This argument also applies to the handle count. 此FTP要求离线信封的大小应正确（递归），以显示当前的离线数据。此要求可能会给编码器带来额外的负担，因为如果接收者希望知道信封的类型，则size字段是不必要的，因为解码器可以计算出size [[3]]（footnote3）。因此，可以说编码器正在执行其他工作而没有明显的好处。此参数也适用于句柄计数。

However, we still recommend that the size and handle count MUST be present, for several reasons: 但是，出于以下几个原因，我们仍然建议务必提供大小和句柄数：

 
1. Consistency: requiring the size means that the envelope encoding is consistent for all use cases, whether it's inside an extensible containeror not.The increased uniformity leads to less code, and a simpler cognitive model. 1.一致性：要求大小意味着信封编码对于所有用例而言都是一致的，无论是在可扩展容器内还是不在扩展容器内。提高的一致性导致更少的代码和更简单的认知模型。
2. _We can change this later_. A future FTP has the option of using a sentinel value for the size (e.g.`UINT48_MAX`) or reserving one of the three LSBs in the size field toindicate that the size is unknown, in which case the decoder must traversethe out-of-line payload and calculate the size itself.This change would not affect the wire format, since the structure of thefields remain the same.It can also be landed as a soft transition since decoders can implementthe logic first, before encoders are updated. 2. _我们稍后可以更改_。将来的FTP可以选择使用哨兵值作为大小（例如“ UINT48_MAX”），或者在大小字段中保留三个LSB之一以指示大小未知，在这种情况下，解码器必须越过线外有效载荷并计算大小本身。此更改不会影响连线格式，因为场的结构保持不变。由于解码器可以在更新编码器之前首先实现逻辑，因此它也可以作为软过渡降落。

Overall, the FTP authors believe that requiring an encoding for an unknown size is possible premature optimization, and advocate starting with a simple,more consistent, uniform design.If we feel that this decision should be re-visited in the future &mdash; e.g.a zero-copy [vectored I/O][vectored-io] encoder becomes available so encodersdon't have to patch up envelopes to write the correct size &mdash; there is aclear path to implementing it in as a soft transition. 总体而言，FTP作者认为要求对未知大小进行编码是可能的过早优化，因此主张从简单，更一致，统一的设计入手。例如，可以使用零拷贝[vectored I / O] [vector-io]编码器，因此编码器不必修补信封即可写出正确的大小-有一个明确的途径可以将其作为软过渡来实施。

 
## Examples  例子 

An optional `uint` stored inline:  可选的uint存储内联：

```fidl
uint32? u = 0xdeadbeef;  // an optional uint: stored inline.
```
 

C++ representation:  C ++表示形式：

```cpp
    vector<uint8_t> object{
        0x01, 0x00, 0x00, 0x00,                          // inline tag
                                0xEF, 0xBE, 0xAD, 0xDE,  // inline data
    };
```
 

An optional `vector<uint16>` stored out-of-line:  脱机存储的可选`vector <uint16>`：

```fidl
vector<uint16>? v = { 10, 11, 12, 13, 14 };  // an optional vector<uint16>; stored out-of-line.
```
 

The out-of-line size is 24:  离线大小为24：

 
*   8 bytes for element count stored out of line as its own secondary object,  * 8个字节的元素计数作为自己的第二个对象存储在行外，
*   + 10 for vector contents (5 elements * `sizeof(uint16_t)`),  * + 10用于矢量内容（5个元素*`sizeof（uint16_t）`），
*   = 18, rounded up to 24 for alignment.  * = 18，四舍五入为24。

C++ representation:  C ++表示形式：

```cpp
    vector<uint8_t> object{
      0x18, 0x00, 0x00, 0x00, 0x00, 0x00,              // envelope size (24)
                                          0x00, 0x00,  // handle count
    };

    vector<uint8_t> sub_objects{
      // element count
      0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      // vector data
      0x0A, 0x00, 0x0B, 0x00, 0x0C, 0x00, 0x0D, 0x00,
      0x0E, 0x00,
      // padding
                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
```
 

A `table` with three fields:  具有三个字段的“表”：

```fidl
table T { 1: int8 i; 2: reserved; 3: int64 j; } = { .i: 241, .j: 71279031231 };
```
 

C++ representation:  C ++表示形式：

```cpp
    // a table is a vector<envelope>, which is represented with an
    // out-of-line envelope
    vector<uint8_t> object{
      0x28, 0x00, 0x00, 0x00, 0x00, 0x00,              // envelope size (40)
                                          0x00, 0x00,  // handle count
    };

    vector<uint8_t> sub_objects{
      // vector element count (max table ordinal)
      0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      // vector[0], 1: int8, stored inline
      0x01, 0x00, 0x00, 0x00,                          // inline tag
                              0xF1, 0x00, 0x00, 0x00   // 241
      // vector[1], 2: reserved
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // zero envelope
      // vector[2], 3: int64, stored out-of-line
      0x08, 0x00, 0x00, 0x00, 0x00, 0x00,              // envelope size
                                          0x00, 0x00,  // handle count
      // vector[2] content
      0xBF, 0xB3, 0x8F, 0x98, 0x10, 0x00, 0x00, 0x00   // 71279031231
    };
```
 

A handle:  一个手柄：

```fidl
handle h;  // decoded to 0xCAFEF00D
```
 

C++ representation:  C ++表示形式：

```cpp
    vector<uint8_t> encoded_form{
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              // envelope size
                                          0x01, 0x00,  // handle count
    };

    vector<uint8_t> decoded_form{
      0x01, 0x00, 0x00, 0x00,                          // inline tag
                              0x0D, 0xF0, 0xFE, 0xCA,  // inline data
    };
```
 

 
## Implementation Strategy  实施策略 

This FTP is a breaking wire format change. Both FIDL peers need to understand the new wire format &mdash; andcommunicate that understanding to its peer &mdash; for both parties to usethe new format. 该FTP是一种断线格式更改。 FIDL的两个同行都需要了解新的电汇格式-并将这种理解传达给其同行mdash；供双方使用新格式。

A soft transition is possible. Two approaches are: 可以进行软过渡。两种方法是：

 
1. There is a `uint32` reserved/flags field in the [transactional message header][wformat-transactional].We can reserve 1 bit for the initiating peer to indicate that itunderstands the new wire format, and soft transition in stages: 1. [事务消息头] [wformat-transactional]中有一个'uint32`保留/标志字段。我们可以为发起端保留1位，以表明它理解新的连线格式，并分阶段进行软转换：
    1. Ensure all clients & servers can understand the old & new wire format. We keep using the old wire format. 1.确保所有客户端服务器都可以理解旧的新有线格式。我们继续使用旧的有线格式。
    2. Enable the new wire format by having a peer set the bit in the transactional message header.If both parties have the bit set, both parties can switch to the newwire format. 2.通过让对方在事务消息头中设置该位来启用新的电汇格式。如果双方都设置了该位，则双方都可以切换到newwire格式。
    3. Once the soft transition has rolled through all the layers, all of Fuchsia can use the new wire format.We can remove setting the bit in the transactional message header. 3.软过渡遍历所有层后，所有的樱红色都可以使用新的电汇格式。我们可以删除设置事务性消息头中的位。
    4. Delete the code for the old wire format, and unreserve the transactional message header bit. 4.删除旧的电汇格式的代码，并取消保留事务性消息标题位。
2. We could decorate specific FIDL message types, interfaces, or both, with a `[WireFormat=EnvelopeV2]` attribute (or similar) that indicates that themessage/interface should use the new wire format. 2.我们可以使用[[WireFormat = EnvelopeV2]]属性（或类似属性）修饰特定的FIDL消息类型和/或界面，这两种属性指示消息/接口应使用新的连线格式。
    1. While decorating an interface with a `[WireFormat]` attribute seems to align better with a wire format change, it should be easier toimplement a WireFormat change on a struct, since the struct could beused in different interfaces, and bindings would need extra logic todetermine the context for which the struct is used. 1.用[[WireFormat]]属性装饰接口似乎更适合于更改有线格式，但在结构上实现WireFormat更改应该更容易，因为该结构可以在不同的接口中使用，并且绑定需要额外的操作确定使用该结构的上下文的逻辑。
    2. We recommend that an interface `[WireFormat]` attribute affect the wire format of the interface's method arguments only, withoutrecursively affecting the argument's structs. 2.我们建议接口[WireFormat]属性仅影响接口方法参数的连线格式，而不会递归影响参数的结构。
    3. This enables partial migration and opt-in to the new wire format, and lets teams move at their own pace. 3.这样可以部分迁移并选择加入新的有线格式，并允许团队按照自己的步调移动。
    4. Once all structs and interfaces have the `[WireFormat]` attribute, we can drop the old wire format, assume all structs & interfaces use thenew wire format, and ignore the attribute. 4.一旦所有结构和接口都具有[WireFormat]属性，我们就可以删除旧的连接格式，假设所有结构接口都使用新的连接格式，然后忽略该属性。

Both these soft transition approaches involve a lot of development time, testing time, and room for error.Implementing the code to do either approach correctly, executing on the plan,and following up successfully to remove old code is a large effort. 这两种软过渡方法都涉及大量的开发时间，测试时间和错误余地。实现代码以正确执行这两种方法，按计划执行并成功跟踪以删除旧代码是一项巨大的工作。

It is likely that we will have code to handle both the old & new wire format at the same time; otherwise, it would not be possible to progressively landCLs as we implement support for the new wire format.Given that the code to handle both wire formats will exist, we recommendprototyping whether a soft transition is feasible using either approach.If not, *c'est la vie*; hard transition it is. 我们很可能将有代码同时处理旧的新线格式。否则，当我们实现对新的有线格式的支持时，将不可能逐步登陆CL。鉴于将存在处理两种有线格式的代码，我们建议使用两种方法对原型进行软过渡是否可行。 est la vie *;很难过渡。

For either a soft or hard transition, any instances in Fuchsia where FIDL messages are hand-rolled would need to also be upgraded to the new wire format. 无论是软过渡还是硬过渡，在紫红色中手动滚动FIDL消息的任何实例都需要升级为新的有线格式。

We should also use this wire format change to fold in other changes that need to happen (e.g. a proposed ordinal size change). 我们还应该使用此有线格式更改来合并其他需要进行的更改（例如，建议的序数大小更改）。

Note that this is an easier transition than FIDL1 to FIDL2, which changed language bindings significantly.We do not propose calling this FIDL3 since there are no user-visiblechanges[[4]](#footnote4) 请注意，这比从FIDL1到FIDL2的过渡要容易得多，后者显着更改了语言绑定。我们不建议调用此FIDL3，因为没有用户可见的更改[[4]]（footnote4）

 
## Backwards Compatibility  向后兼容 

The proposed wire format change is API (source) compatible, with one exception: C bindings will be a breaking API change if we move thevector/string element count to be out-of-line.We can mitigate this by planning ahead and abstracting the current C bindingswith macros or functions, before the new wire format lands. 提议的有线格式更改与API（源代码）兼容，但有一个例外：如果将vector / string元素计数移到线外，C绑定将是一个重大的API更改。我们可以通过提前计划并抽象化来缓解这种情况。在使用新的有线格式之前，当前的C绑定具有宏或函数。

The wire format change is ABI-incompatible, but it is possible to achieve ABI compatibility with existing code via the strategies outlined in the [ImplementationStrategy](#implementation-strategy) section. 有线格式更改与ABI不兼容，但是可以通过[实施策略]（实施策略）部分中概述的策略实现与现有代码的ABI兼容性。

 
## Performance  性能 

This FTP significantly shrinks the size required for envelopes, which seems like it would be an overall significant net benefit.However, the overall performance implications are less clear.In favor of better performance: 该FTP大大缩小了信封所需的大小，这似乎将带来总体上的显着净收益，但是总体性能影响尚不明确。

 
*   FIDL messages that use extensible data structures (tables & extensible unions) will become significantly more compact. *使用可扩展数据结构（表可扩展联合）的FIDL消息将变得更加紧凑。
*   Having a uniform representation for envelopes and optionality may reduce code size and improve cache locality, since envelope code can be shared. *由于信封可以共享，因此具有统一的信封表示形式和可选性可以减小代码大小并提高缓存的局部性。

However:  然而：

 
*   If extensible data structures become more pervasive due to their better efficiency, this may be outweighed by their increased usage, which mayresult in less compact messages and more dynamic allocation, vs usingnon-extensible data structures. *如果可扩展的数据结构由于效率更高而变得更加普遍，那么与使用不可扩展的数据结构相比，增加的使用量可能会抵消它的不足，这可能会导致消息紧凑程度降低和动态分配更多。
*   Introducing optionality for all types may make FIDL messages slightly larger, since users may use this feature to make some previouslynon-optional types optional. *对所有类型引入可选性可能会使FIDL消息稍大，因为用户可以使用此功能使某些以前的非可选类型为可选。
*   Optional handles become less efficient, if we decide to use the envelope encoding for optional handles. *如果我们决定对可选句柄使用信封编码，则可选句柄的效率会降低。
*   As discussed in [Encoding Sizes for Out-of-Line Envelopes](#encoding-sizes-for-out_of_line-envelopes), encoding the sizeand handle count in an envelope for a type that a receiver will know isa performance regression from the current behavior. *如[编码外线信封的大小]（encoding-sizes-for-out_of_line_envelopes）中所讨论的，在信封中编码大小和句柄数，以使接收者知道当前行为是性能下降。

 
## Ergonomics  人机工程学 

 
*   Optionality can be enabled for all FIDL types. This is an ergonomic improvement, since optionality becomes consistent,instead of only for specific types. *可以为所有FIDL类型启用可选性。这是人机工程学上的改进，因为可选性变得一致，而不是仅针对特定类型。
*   More efficient extensible data structures enable them to be used in more contexts where efficiency matters, so users need to worry less about theirperformance, and can gain the benefits of extensibility where they wouldpreviously need to use non-extensible structures. *更高效的可扩展数据结构使它们可以在效率至关重要的更多上下文中使用，因此用户无需担心性能，并可以在以前需要使用不可扩展结构的情况下获得可扩展性的好处。
    *   We may even wish to recommend that tables should be used by default for FIDL data structures, and structs should be reserved forhigh-performance contexts. *我们甚至可能建议在默认情况下，将表用于FIDL数据结构，并且应为高性能上下文保留结构。
    *   Extensible unions ([FTP-015][ftp-015]) are already attempting to remove static unions. *可扩展联合（[FTP-015] [ftp-015]）已经在尝试删除静态联合。

 
## Documentation  文献资料 

 
*   The wire format documentation needs to be updated.  *线格式文档需要更新。
*   When updating the documentation, envelopes should be explained as a first-class concept: this enables better [cognitivechunking][cognitive-chunking] once readers encounter the wire format foroptionality and extensible data structures. *在更新文档时，应该将信封解释为一流的概念：一旦读者遇到可选格式和可扩展数据结构的有线格式，这将使[cognitivechunking] [cognitive-chunking]更好。
*   We should update the FIDL style guide to make recommendations for when optional types should be used (vs non-optional types with sentinel values). *我们应该更新FIDL样式指南，为何时应该使用可选类型（相对于带有哨兵值的非可选类型）提出建议。

 
## Security  安全 

 
*   There should no significant security implications from this FTP.  *该FTP不会有重大的安全隐患。
*   However, the bit-twiddling needed to manipulate the out-of-line and inline envelope formats should be significantly well tested andconservative to ensure that code properly handles edge cases.We do feel that the use of standard C/C++ struct/unions to representenvelopes &mdash; as opposed to manual bit shifts & masking &mdash;greatly increases our confidence in code correctness. *但是，处理外联和内联信封格式所需的位纠缠机制应经过充分测试和保守，以确保代码正确处理边缘情况。我们确实认为使用标准C / C ++结构/联合来代表信封-与手动移位掩盖mdash相对；极大地提高了我们对代码正确性的信心。

 
## Testing  测试中 

 
*   Since this FTP is changing the wire format for envelopes, we feel that the existing FIDL test suite &mdash; particularly compatibility tests&mdash; will adequately test all scenarios where envelopes are used. *由于此FTP更改了信封的线路格式，因此我们认为现有的FIDL测试套件会变短；特别是兼容性测试将充分测试所有使用信封的情况。
*   We will add unit tests for envelope parsing, encoding and decoding for out-of-line and inline forms, since that is a potentially error-prone area. *我们将添加单元测试，以便对行外和内联形式的信封进行解析，编码和解码，因为这是一个潜在的容易出错的区域。
*   If we agree to land the wire format change as a soft transition (see the [Implementation Strategy](#implementation-strategy) section), we will addtests for peers to negotiate and possibly switch to the new wire format. *如果我们同意将有线格式更改作为一种软过渡（请参阅[实施策略]（实施策略）部分），我们将进行测试以供同行进行协商，并有可能切换到新的有线格式。
*   If we agree to expose optionality for all types as part of this change, we will need to add tests for any types that can become optional. *如果作为更改的一部分，如果我们同意公开所有类型的可选性，我们将需要为可能变为可选的任何类型添加测试。

 
## Drawbacks, Alternatives, and Unknowns  缺点，替代方案和未知数 

 
*   We can keep the existing wire format if we believe the efficiency gains in this proposal are not worth the implementation cost.If so, we will want to find an alternative strategy to implementoptionality for all types. *如果我们认为此提案中的效率提高不值得实施成本，那么我们可以保留现有的线格式，如果是这样，我们将希望找到一种替代策略来实现所有类型的可选性。
*   Using specialized representations for extensible containers and optional types will likely be more efficient than using an envelope for all cases.However, since this FTP exists, we obviously feel that the increasedgenericity and uniformity that envelopes provide outweigh the efficiencygains for specialized representations. *对于所有情况，使用可扩展容器和可选类型的专用表示比使用信封可能更有效。但是，由于存在此FTP，因此我们显然感到，信封提供的增强的通用性和统一性超过了专用表示的效率增益。

 
## Design Decisions  设计决策 

While this FTP makes recommendations, we are actively seeking input and consensus on the following decisions:  在此FTP提出建议的同时，我们正在积极寻求有关以下决定的意见和共识：

 
*   See the [Strings & Vectors](#strings-vectors) section for discussion about moving the element count (vector) and byte count (string)out-of-line, which affects the C bindings.We can opt not to do this, at the cost of less uniformity: strings &vectors become exceptions to envelopes being used for all out-of-linereferences.(An envelope can still be used to refer to the out-of-line vector/stringdata.) *请参见[Strings Vectors]（strings-vectors）部分，以讨论关于移出元素计数（向量）和字节计数（string）的行外行为，这会影响C绑定。我们可以选择不执行此操作一致性降低的代价：字符串向量成为用于所有线外引用的信封的例外（仍然可以使用信封来引用线外向量/字符串数据。）
*   Do we want to consider a soft transition or a hard transition? See the [Implementation Strategy](#implementation-strategy) section for pros & cons. *我们要考虑软过渡还是硬过渡？优点请参见[实施策略]（实施策略）部分。
*   We propose using 48 bits for size and 16 bits for handles in the out-of-line envelope.For comparison, the current envelope format uses 32/32 bits.Is 48 bits for size reasonable? *我们建议在离线信封中使用48位的大小并使用16位的句柄进行比较，当前的信封格式使用32/32位.48位的大小是否合理？
    *   For size, we can encode a size up to 50 bits by right-shifting 2 bits in the encoded form, since the envelope size is always a multiple of 8.(We cannot right-shift three bits, since that cannot guarantee that the[tag bit](#tag-bit) is 0.)The decoder would left-shift two bits to determine the size.We then lose two extra bits that may be used for flags or more tags. *对于大小，由于包络大小始终为8的倍数，因此我们可以通过以编码形式右移2位来对最大50位的大小进行编码。（我们无法右移3位，因为这不能保证[tag bit]（tag-bit）为0。）解码器将左移两位以确定大小。然后，我们丢失了两个额外的位，可用于标记或更多标签。
    *   While current 64-bit architectures typically don't allow the entire 64-bit memory space to be addressed, and typically allow up to 48 bits,some architectures are already enabling address spaces up to 57 bits large.See [References](#prior-art-and-references) for more details. *虽然当前的64位体系结构通常不允许寻址整个64位存储器空间，并且通常最多允许48位寻址，但是某些体系结构已经允许最大57位的地址空间。请参阅[参考文献] -art-and-references）以获取更多详细信息。
    *   Is 16 bits for handles reasonable?  * 16位的句柄合理吗？
*   We propose using an envelope to encode an optional handle in a non-extensible container, which is less compact than the current optionalhandle encoding (8 bytes vs 4 bytes). *我们建议使用信封在不可扩展的容器中对可选句柄进行编码，这比当前的可选句柄编码（8字节vs 4字节）紧凑。
    *   There is a trade-off between compactness & more specialized code vs consistency here.We believe consistency and uniformity is more important than aspecialized, more compact representation since optional handles arelikely to be relatively rare use case.(37 optional uses in code vs 187 non-optional.) *紧凑性更专业的代码与一致性之间需要权衡取舍。我们认为一致性和统一性比专业化，更紧凑的表示更为重要，因为可选句柄可能是相对罕见的用例（代码中的37种可选用法与187种非可选用法） -可选的。）
*   Do we enable optionality immediately?  *我们是否立即启用可选性？
    *   We propose exposing optionality for all types in a separate transition from upgrading the wire format, since the change can bedone incrementally. *我们建议在升级有线格式后的单独过渡中公开所有类型的可选性，因为更改可以逐步解决。
    *   Implementing such optionality would require changes to the parser, encoders, validators and decoders, which feels large enough towarrant being its own transition. *实现这样的可选性需要对解析器，编码器，验证器和解码器进行更改，这些感觉足够大，可以保证自己进行转换。
*   We propose inlining types that are <= 32 bits; we could inline more aggressively. *我们建议小于32位的内联类型；我们可以更积极地内联。
    *   We can inline any data <= 63 bits, since the tag bit only uses one bit in the 64-bit envelope. *我们可以内联任何<= 63位的数据，因为标记位仅使用64位包络中的一位。
    *   We can inline small strings & vectors by using a specialized representation for them, e.g. one byte for the element/byte count,followed by the string/vector data. (See [PriorArt](#prior-art-and-references) for inspiration). *我们可以使用专门的表示法内嵌小字符串向量，例如元素/字节计数一个字节，然后是字符串/向量数据。 （有关灵感，请参阅[PriorArt]（现有技术和参考文献））。
    *   We discarded these approaches even though they're more efficient, since inlining based on the content instead of the type means that(1) decoders cannot know in advance whether to expect an inline orout-of-line envelope or not based on the type, and (2) changing afield's contents means that it can be encoded differently, whichseems contrary to FIDL's goals and static focus. *我们放弃了这些方法，尽管它们效率更高，因为基于内容而不是类型的内联意味着（1）解码器无法提前知道是否期望基于类型的内联或外联包络，以及（2）更改字段的内容意味着可以对其进行不同的编码，这似乎与FIDL的目标和静态焦点背道而驰。

 
## Prior Art and References  现有技术和参考 

The authors took a lot of inspiration from existing uses of [tagged pointers](https://en.wikipedia.org/wiki/Tagged_pointer), which have a longhistory in dynamic and functional languages.In particular, the Objective-C 64-bit runtime makes [heavy use][objective-c-pointers]of them for better performance (even going so far as using specialized[5/6-bit encodings for inline strings][objective-c-strings]). 作者从[标记指针]（https://en.wikipedia.org/wiki/Tagged_pointer）的现有用法中汲取了很多灵感，这些标记在动态和功能语言方面有着悠久的历史。特别是Objective-C 64-位运行时使它们[大量使用] [objective-c-pointers]以获得更好的性能（甚至可以使用专门的[5/6位内联字符串编码] [objective-c-strings]）。

Since current 64-bit platforms tend to use 48 bits ([or less][pointer-encoding]) to encode a pointer, we considered stealing morebits from the decoded pointer with bit-shifting to attempt to encode anout-of-line object's size along in the pointer.However, some architectures are already expanding their physical addressspace past 48 bits ([ARM64][arm-physical], [x64-64 5-levelpaging][x86-physical]), so stealing more pointer bits may not be veryfuture-proof. 由于当前的64位平台倾向于使用48位（[或更少] [pointer-encoding]）对指针进行编码，因此我们考虑通过移码从解码的指针中窃取更多位，以尝试对行外对象的大小进行编码但是，某些体系结构已经将其物理地址空间扩展到超过48位（[ARM64] [arm-physical]，[x64-64 5-levelpaging] [x86-physical]），因此可能无法窃取更多的指针位非常耐将来。

--------------------------------------------------------------------------------  -------------------------------------------------- ------------------------------

 
##### Footnote1  脚注1Envelopes _enable_ optionality for all types; however, exposing this optionality to end-users can (and perhaps should) be done separately. 所有类型的信封都可以启用；但是，可以（可能应该）单独向最终用户展示这种可选性。

 
##### Footnote2  脚注2As of 1/28/19, there appears to be 37 uses of optional handles in the Fuchsia code base.This is a conservative number, as it does not count optional protocolhandles, nor protocol request handles. 截至19/1/28，紫红色代码库中似乎有37种使用可选句柄，这是一个保守的数字，因为它不计入可选协议句柄或协议请求句柄。

 
##### Footnote3  脚注3This only applies to envelopes in non-extensible containers, i.e. structs and static unions.Extensible containers must encode the recursive size since decoders may notknow the type, and need to know how much data to ignore. 这仅适用于不可扩展容器中的信封，即结构和静态联合。可扩展容器必须对递归大小进行编码，因为解码器可能不知道类型，并且需要知道要忽略多少数据。

 
##### Footnote4  脚注4Except allowing optionality on more types, if we wish to do that simultaneously.  除了允许在更多类型上具有可选性之外，如果我们希望同时做到这一点。

<!-- xrefs --> [FTP-032]: ftp-032.md[FTP-015]: ftp-015.md[wformat-handles]: /docs/development/languages/fidl/reference/wire-format/README.md#Handles[wformat-strings]: /docs/development/languages/fidl/reference/wire-format/README.md#Strings[wformat-vectors]: /docs/development/languages/fidl/reference/wire-format/README.md#Vectors[wformat-transactional]: /docs/development/languages/fidl/reference/wire-format/README.md#Transactional-Messages[flexible-array-members]: https://en.wikipedia.org/wiki/Flexible_array_member[vectored-io]: https://en.wikipedia.org/wiki/Vectored_I/O[cognitive-chunking]: https://en.wikipedia.org/wiki/Chunking_(psychology)[tagged-pointers]: https://en.wikipedia.org/wiki/Tagged_pointer[objective-c-pointers]: https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html[objective-c-strings]: https://www.mikeash.com/pyblog/friday-qa-2015-07-31-tagged-pointer-strings.html[pointer-encoding]: http://www.alex-ionescu.com/?p=50[arm-physical]: https://lwn.net/Articles/741776/[x86-physical]: https://en.wikipedia.org/wiki/Intel_5-level_paging <！-外部参照-> [FTP-032]：ftp-032.md [FTP-015]：ftp-015.md [wformat-h​​andles]：/ docs / development / languages / fidl / reference / wire-format /README.mdHandles[wformat-strings]：/docs/development/languages/fidl/reference/wire-format/README.mdStrings[wformat-vectors]：/ docs / development / languages / fidl / reference / wire-format / README .mdVectors [wformat-transactional]：/docs/development/languages/fidl/reference/wire-format/README.mdTransactional-Messages[flexible-array-members]：https://en.wikipedia.org/wiki/Flexible_array_member [ vectored-io]：https://en.wikipedia.org/wiki/Vectored_I/O[cognitive-chunking]：https://en.wikipedia.org/wiki/Chunking_（psychology）[tagged-pointers]：https： //en.wikipedia.org/wiki/Tagged_pointer[objective-c-pointers]：https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html [objective-c-strings]：https://www.mikeash.com/pyblog/friday-qa-2015-07-31-tagged-pointer-strings.html[pointer-encoding]：http：//www.alex -ionescu.com/?p=50[arm-physical]：https://lwn.ne t / Articles / 741776 / [x86-physical]：https://en.wikipedia.org/wiki/Intel_5-level_paging

