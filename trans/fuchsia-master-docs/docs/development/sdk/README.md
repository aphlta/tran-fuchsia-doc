 
# SDK  开发包 

This folder contains information about developing the Fuchsia SDK.  此文件夹包含有关开发Fuchsia SDK的信息。

> [Download the Fuchsia Core SDK](download.md)  > [下载Fuchsia Core SDK]（download.md）

 

 
## Strategy {#strategy}  策略{策略} 

Fuchsia is taking a modular approach to building an SDK, just as it took one to building a new operating system. 紫红色正在采用模块化方法来构建SDK，就像构建新操作系统一样。

At the center of this strategy is the Fuchsia Core SDK, distilled out of the present Git repository.This SDK contains a small set of libraries and tools required to start buildingand running programs that target Fuchsia.The contents of that SDK represent the most basic contract that the Fuchsiaplatform developers offer to prospective developers. 该策略的核心是从当前Git存储库中提炼出来的Fuchsia Core SDK.SDK包含一小部分库和工具，这些库和工具用于开始构建和运行针对Fuchsia的程序.SDK的内容代表了最基本的契约Fuchsiaplatform开发人员提供给潜在开发人员的功能。

The Fuchsia Core SDK is not suitable for immediate consumption. It does not contain any reference to toolchains or build systems, and in factdoes not require any specific instance of these.While this might be viewed as a drawback, this is actually a feature, anintegral part of a layered approach to building a fully-functional SDK.Even though it is not tied to a particular build system, the Core SDK containsmetadata that may be used to produce support for a large variety of buildsystems, thereby producing various SDK distributions.Having the Core SDK cleanly separated from these various distributions allowsfor very flexible release schemes and iteration cycles. Fuchsia Core SDK不适合立即使用。它不包含任何对工具链或构建系统的引用，并且实际上不需要这些特定的实例。虽然这可能被视为一个缺点，但这实际上是一个功能，是构建全功能的分层方法的组成部分即使没有与特定的构建系统绑定，SDK也包含元数据，这些元数据可用于为多种构建系统提供支持，从而生成各种SDK发行版。灵活的发布方案和迭代周期。

The present documentation focuses on the details of the creation process of the Core SDK.The documentation included in the Core SDK, hosted under `//sdk/docs`, containsinformation regarding how to work with the Core SDK.Lastly, some examples of SDK distributions can be found under `//scripts/sdk`;most notably it contains a [frontend](#frontend) generating a workspaceenabling Fuchsia development using [Bazel][bazel] - this distribution iscurrently used to test versions of the Core SDK before they are published. 本文档重点介绍Core SDK的创建过程的详细信息。CoreSDK中包含的文档（位于// sdk / docs下）包含有关如何使用Core SDK的信息。最后，SDK的一些示例发行版可以在`// scripts / sdk`下找到；最值得注意的是，它包含一个[frontend]（frontend）生成一个使用[Bazel] [bazel]进行Fuchsia开发的工作区-该发行版目前用于测试Core SDK版本被出版。

 

 
## What belongs in an SDK? {#what-belongs-in-an-sdk}  SDK中包含什么？ {在SDK中属于什么} 

By default, a piece of code in the Fuchsia tree cannot be added to any SDK: participation is a strictly opt-in decision. Additionally, this decision isencoded locally within the code's build file. This was done for multiplereasons: 默认情况下，紫红色树中的一段代码无法添加到任何SDK：参与是严格的选择决定。此外，此决策在代码的构建文件中本地编码。这样做是出于多种原因：

 
1. developers modifying the code need to be aware of the potential impact on external customers as early as possible; 1.修改代码的开发人员需要尽早意识到对外部客户的潜在影响；
1. publishing that code to an SDK may require extra input from the developers to inform the build system about how to properly include that code in an SDK; 1.将代码发布到SDK可能需要开发人员的额外投入，以告知构建系统如何在SDK中正确包含该代码；
1. knowing whether the code may be included in an SDK or not allows the build system to perform extra checks on that code to ensure conformity with SDKstandards. 1.知道代码是否可以包含在SDK中，使构建系统可以对该代码执行额外的检查，以确保符合SDK标准。

In order to be made available in SDKs, a piece of code must follow a set of [standards and guidelines](standards.md). 为了在SDK中可用，一段代码必须遵循一组[standards and Guidelines]（standards.md）。

 

 
## Infrastructure {#infrastructure}  基础设施{infrastructure} 

The SDK creation pipeline consists of two pieces:  SDK创建管道包括两部分：

 
1. the backend, which uses the build system to generate a tarball containing compiled artifacts, source files, and metadata; 1.后端，它使用构建系统生成一个包含编译后的工件，源文件和元数据的压缩包；
1. the frontend, which applies transformations to that tarball and turn into e.g. an SDK distribution. 1.前端，它将转换应用于该压缩包并转换为例如SDK发行版。

 
### Backend {#backend}  后端{backend} 

The backend really is just a specialized use of the build system. In other words, running the SDK backend amounts to passing the right set of arguments tothe Fuchsia build system, which in turn produces an archive with a[set layout](layout.md).The inner workings of the backend are described [here][backend]. 后端实际上只是构建系统的一种专门用途。换句话说，运行SDK后端等于将正确的参数集传递给Fuchsia构建系统，该系统进而生成带有[设置布局]（layout.md）的档案。后端的内部工作原理在[此处]有描述。 [后端]。

The backend does not just produce an SDK: it is also used as a control mechanism for API evolution. The API surface exposed by an SDK is captured in a set ofreference files representing its elements: modifications to this surface need tobe explicitly acknowledged by developers by updating the relevant referencefiles, whose latest version is also generated by the backend. The purpose ofthis mechanism is to detect and prevent accidental changes to the SDK as earlyas possible in the release cycle, as well as give us tools to observe and reviewthe evolution of the API surface. 后端不仅产生SDK，还用作API演变的控制机制。 SDK公开的API表面被捕获在代表其元素的一组参考文件中：开发人员需要通过更新相关参考文件来明确确认对此表面的修改，该参考文件的最新版本也由后端生成。该机制的目的是在发布周期中尽早检测并防止对SDK的意外更改，并为我们提供观察和审查API表面演变的工具。

 
### Frontend {#frontend}  前端{frontend} 

The term frontend is used to describe any process that ingests a Fuchsia SDK archive and applies transformations to it. 术语“前端”用于描述任何提取Fuchsia SDK归档文件并对其进行转换的过程。

[In the Fuchsia tree][frontends], frontends are used to generate SDK distributions, e.g. a Bazel-ready workspace. [在紫红色的树中] [前端]，前端用于生成SDK分发，例如Bazel就绪工作区。

Frontends may also be used to adapt a Fuchsia SDK archive for consumption in a particular development environment by for example generating build files for agiven build system. The presence of extensive metadata in the archive itselfallows for this kind of processing. 前端还可以用于例如通过为给定的构建系统生成构建文件来使Fuchsia SDK存档适应特定开发环境中的使用。存档中大量元数据的存在本身允许进行这种处理。

 

 
## Core SDK and SDK add-ons {#core-sdk-and-sdk-add-ons}  核心SDK和SDK附加组件{core-sdk-and-sdk-add-ons} 

The Core SDK is represented by the `//sdk:core` target. That SDK is complemented by multiple SDK add-ons: 核心SDK由`// sdk：core`目标表示。该SDK由多个SDK附加组件补充：

 
- `//sdk:e2e_testing`: an end-to-end testing framework for Fuchsia;  -`// sdk：e2e_testing`：紫红色的端到端测试框架；
- `//sdk:modular_testing`: an hermetic testing framework for the app framework;  -`// sdk：modular_testing`：用于应用程序框架的密封测试框架；
- `//topaz/public/sdk:fuchsia_dart`: a Dart SDK to build mods and agents.  -`// topaz / public / sdk：fuchsia_dart`：Dart SDK，用于构建mod和代理。

Internally these targets are all instances of the `sdk` GN template.  在内部，这些目标是sdk GN模板的所有实例。

 

 
## Recipes {#recipes}  食谱{食谱} 

 
### Generating an SDK archive {#generating-an-sdk-archive}  生成SDK存档{generating-an-sdk-archive} 

The various targets representing SDKs are always included in the build graph. In order to build the contents of an SDK, [build][fx-build-target] one of thetargets above. 表示SDK的各种目标始终包含在构建图中。为了构建SDK的内容，请[build] [fx-build-target]上面的目标之一。

Note that this will generate and verify SDK contents, but won't actually build an archive with these contents.To build the archive, add the GN argument `build_sdk_archives=true` [to yourbuild configuration][fx-config] and run the build command again.The resulting archive will be located under`<outdir>/sdk/archive/<name>.tar.gz`. 请注意，这将生成并验证SDK内容，但实际上不会使用这些内容构建存档。要构建存档，请将GN参数`build_sdk_archives = true` [添加到您的构建配置] [fx-config]中并运行构建再次命令。生成的存档将位于<outdir> / sdk / archive / <name> .tar.gz`下。

 
### Adding content to an SDK {#adding-content-to-an-sdk}  将内容添加到SDK {向一个SDK添加内容} 

The first step is to make that content available to SDKs. This is done by using a set of templates listed in the [backend documentation][backend].The next step is to add that content to an existing SDK definition. For a target`//path/to/my:super_target`, this is accomplished by making the implicit`//path/to/my:super_target_sdk` target a dependency of the `sdk` target. 第一步是使这些内容可用于SDK。这是通过使用[后端文档] [后端]中列出的一组模板来完成的。下一步是将该内容添加到现有的SDK定义中。对于目标“ // path / to / my：super_target”，这是通过使隐式“ // path / to / my：super_target_sdk”目标与“ sdk”目标相关而实现的。

Note that some content types require a `.api` source file describing the state of the SDK element's API.These files are produced by the build system.In order to seed the first version of such a file, let the build system tell youwhere it expects to find the file, then create this file and leave it empty,and finally run the build again: it will again tell you where to get the initialversion from. 注意某些内容类型需要一个`.api`源文件来描述SDK元素的API状态，这些文件是由构建系统生成的。为了播种该文件的第一个版本，让构建系统告诉您它在哪里希望找到该文件，然后创建此文件并将其保留为空，最后再次运行构建：它将再次告诉您从何处获取initialversion。

 
### Turning SDK-related errors into warnings {#turning-sdk-related-errors}  将与SDK相关的错误转化为警告{turning-sdk-related-errors} 

There exist some build steps to verify that the contents of an SDK don't get modified by accident. An unacknowledged modification results in a build failureuntil the relevant reference files are updated in the source tree.While locally iterating on some public API, having to repeatedly updatereference files can be tedious. In order to turn the build errors into warnings,configure then build with this extra GN argument: `warn_no_sdk_changes=true`. 有一些构建步骤可以验证SDK的内容不会被意外修改。未经确认的修改会导致构建失败，直到在源代码树中更新相关参考文件为止。虽然在某些公共API上进行本地迭代，但必须重复更新参考文件可能很繁琐。为了将构建错误变成警告，请配置并使用以下额外的GN参数进行构建：`warn_no_sdk_changes = true。

 
### Producing an SDK distribution {#producing-an-sdk-distribution}  制作SDK发行版{production-an-sdk-distribution} 

This is done by running a frontend. See the [frontend documentation][frontends] for more details. 这是通过运行前端来完成的。有关更多详细信息，请参见[前端文档] [前端]。

 

